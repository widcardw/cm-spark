[{"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[AFTSurvivalRegression]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setAggregationDepth", "detail": "->AFTSurvivalRegression", "apply": "setAggregationDepth(${\"value: number\"})", "info": "\n<pre>(['value: number'])->AFTSurvivalRegression \n\nsetAggregationDepth(%d)\n</pre>\n<hr class=\"solid\">\n<p>[AFTSurvivalRegression]</p>\n<p>Suggested depth for tree. (Spark 2.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setCensorCol", "detail": "->AFTSurvivalRegression", "apply": "setCensorCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->AFTSurvivalRegression \n\nsetCensorCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[AFTSurvivalRegression]</p>\n<p>Param for censor column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->AFTSurvivalRegression", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->AFTSurvivalRegression \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[AFTSurvivalRegression]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFitIntercept", "detail": "->AFTSurvivalRegression", "apply": "setFitIntercept(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->AFTSurvivalRegression \n\nsetFitIntercept(%b)\n</pre>\n<hr class=\"solid\">\n<p>[AFTSurvivalRegression]</p>\n<p>Set if we should fit the intercept. Default is true.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLabelCol", "detail": "->AFTSurvivalRegression", "apply": "setLabelCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->AFTSurvivalRegression \n\nsetLabelCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[AFTSurvivalRegression]</p>\n<p>Param for label column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxIter", "detail": "->AFTSurvivalRegression", "apply": "setMaxIter(${\"value: number\"})", "info": "\n<pre>(['value: number'])->AFTSurvivalRegression \n\nsetMaxIter(%d)\n</pre>\n<hr class=\"solid\">\n<p>[AFTSurvivalRegression]</p>\n<p>Set the maximum number of iterations. Default is 100.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->AFTSurvivalRegression", "apply": "setPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->AFTSurvivalRegression \n\nsetPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[AFTSurvivalRegression]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setQuantileProbabilities", "detail": "->AFTSurvivalRegression", "apply": "setQuantileProbabilities(${\"value: [number](Array)\"})", "info": "\n<pre>(['value: [number]'])->AFTSurvivalRegression \n\nsetQuantileProbabilities(%@f)\n</pre>\n<hr class=\"solid\">\n<p>[AFTSurvivalRegression]</p>\n<p>Param for quantile probabilities array.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setQuantilesCol", "detail": "->AFTSurvivalRegression", "apply": "setQuantilesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->AFTSurvivalRegression \n\nsetQuantilesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[AFTSurvivalRegression]</p>\n<p>Param for quantiles column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setTol", "detail": "->AFTSurvivalRegression", "apply": "setTol(${\"value: number\"})", "info": "\n<pre>(['value: number'])->AFTSurvivalRegression \n\nsetTol(%f)\n</pre>\n<hr class=\"solid\">\n<p>[AFTSurvivalRegression]</p>\n<p>Set the convergence tolerance of iterations. Smaller value will lead to higher accuracy with the cost of more iterations. Default is 1E-6.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[ALS]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setAlpha", "detail": "->ALS", "apply": "setAlpha(${\"value: number\"})", "info": "\n<pre>(['value: number'])->ALS \n\nsetAlpha(%f)\n</pre>\n<hr class=\"solid\">\n<p>[ALS]</p>\n<p>Param for the alpha parameter in the implicit preference formulation (nonnegative).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setColdStartStrategy", "detail": "->ALS", "apply": "setColdStartStrategy(${\"value: string\"})", "info": "\n<pre>(['value: string'])->ALS \n\nsetColdStartStrategy(%s)\n</pre>\n<hr class=\"solid\">\n<p>[ALS]</p>\n<p>Param for strategy for dealing with unknown or new users/items at prediction time. (Spark 2.2)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setCheckpointInterval", "detail": "->ALS", "apply": "setCheckpointInterval(${\"value: number\"})", "info": "\n<pre>(['value: number'])->ALS \n\nsetCheckpointInterval(%d)\n</pre>\n<hr class=\"solid\">\n<p>[ALS]</p>\n<p>Param for set checkpoint interval (>= 1) or disable checkpoint (-1).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFinalStorageLevel", "detail": "->ALS", "apply": "setFinalStorageLevel(${\"value: string\"})", "info": "\n<pre>(['value: string'])->ALS \n\nsetFinalStorageLevel(%s)\n</pre>\n<hr class=\"solid\">\n<p>[ALS]</p>\n<p>Param for StorageLevel for ALS model factors. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setImplicitPrefs", "detail": "->ALS", "apply": "setImplicitPrefs(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->ALS \n\nsetImplicitPrefs(%b)\n</pre>\n<hr class=\"solid\">\n<p>[ALS]</p>\n<p>Param to decide whether to use implicit preference.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setIntermediateStorageLevel", "detail": "->ALS", "apply": "setIntermediateStoragetLevel(${\"value: string\"})", "info": "\n<pre>(['value: string'])->ALS \n\nsetIntermediateStoragetLevel(%s)\n</pre>\n<hr class=\"solid\">\n<p>[ALS]</p>\n<p>Param for StorageLevel for intermediate datasets. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setItemCol", "detail": "->ALS", "apply": "setItemCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->ALS \n\nsetItemCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[ALS]</p>\n<p>Param for the column name for item ids.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxIter", "detail": "->ALS", "apply": "setMaxIter(${\"value: number\"})", "info": "\n<pre>(['value: number'])->ALS \n\nsetMaxIter(%d)\n</pre>\n<hr class=\"solid\">\n<p>[ALS]</p>\n<p>Param for maximum number of iterations (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setNonnegative", "detail": "->ALS", "apply": "setNonnegative(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->ALS \n\nsetNonnegative(%b)\n</pre>\n<hr class=\"solid\">\n<p>[ALS]</p>\n<p>Param for whether to apply nonnegativity constraints.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setNumBlocks", "detail": "->ALS", "apply": "setNumBlocks(${\"value: number\"})", "info": "\n<pre>(['value: number'])->ALS \n\nsetNumBlocks(%d)\n</pre>\n<hr class=\"solid\">\n<p>[ALS]</p>\n<p>Sets both numUserBlocks and numItemBlocks to the specific value.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setNumItemBlocks", "detail": "->ALS", "apply": "setNumItemBlockes(${\"value: number\"})", "info": "\n<pre>(['value: number'])->ALS \n\nsetNumItemBlockes(%d)\n</pre>\n<hr class=\"solid\">\n<p>[ALS]</p>\n<p>Param for number of item blocks (positive).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setNumUserBlockes", "detail": "->ALS", "apply": "setNumUserBlocks(${\"value: number\"})", "info": "\n<pre>(['value: number'])->ALS \n\nsetNumUserBlocks(%d)\n</pre>\n<hr class=\"solid\">\n<p>[ALS]</p>\n<p>Param for number of user blocks (positive).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->ALS", "apply": "setPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->ALS \n\nsetPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[ALS]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setRank", "detail": "->ALS", "apply": "setRank(${\"value: number\"})", "info": "\n<pre>(['value: number'])->ALS \n\nsetRank(%d)\n</pre>\n<hr class=\"solid\">\n<p>[ALS]</p>\n<p>Param for rank of the matrix factorization (positive).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setRatingCol", "detail": "->ALS", "apply": "setRatingCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->ALS \n\nsetRatingCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[ALS]</p>\n<p>Param for the column name for ratings.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setRegParam", "detail": "->ALS", "apply": "setRegParam(${\"value: number\"})", "info": "\n<pre>(['value: number'])->ALS \n\nsetRegParam(%f)\n</pre>\n<hr class=\"solid\">\n<p>[ALS]</p>\n<p>Param for regularization parameter (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSeed", "detail": "->ALS", "apply": "setSeed(${\"value: number\"})", "info": "\n<pre>(['value: number'])->ALS \n\nsetSeed(%d)\n</pre>\n<hr class=\"solid\">\n<p>[ALS]</p>\n<p>Param for random seed.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setUserCol", "detail": "->ALS", "apply": "setUserCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->ALS \n\nsetUserCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[ALS]</p>\n<p>Param for the column name for user ids.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[BisectingKMeans]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->BisectingKMeans", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->BisectingKMeans \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[BisectingKMeans]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setK", "detail": "->BisectingKMeans", "apply": "setK(${\"value: number\"})", "info": "\n<pre>(['value: number'])->BisectingKMeans \n\nsetK(%d)\n</pre>\n<hr class=\"solid\">\n<p>[BisectingKMeans]</p>\n<p>The desired number of leaf clusters.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxIter", "detail": "->BisectingKMeans", "apply": "setMaxIter(${\"value: number\"})", "info": "\n<pre>(['value: number'])->BisectingKMeans \n\nsetMaxIter(%d)\n</pre>\n<hr class=\"solid\">\n<p>[BisectingKMeans]</p>\n<p>Param for maximum number of iterations (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMinDivisibleCusterSize", "detail": "->BisectingKMeans", "apply": "setMinDivisibleClusterSize(${\"value: number\"})", "info": "\n<pre>(['value: number'])->BisectingKMeans \n\nsetMinDivisibleClusterSize(%f)\n</pre>\n<hr class=\"solid\">\n<p>[BisectingKMeans]</p>\n<p>The minimum number of points or the minimum proportion of points of a divisible cluster.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->BisectingKMeans", "apply": "setPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->BisectingKMeans \n\nsetPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[BisectingKMeans]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSeed", "detail": "->BisectingKMeans", "apply": "setSeed(${\"value: number\"})", "info": "\n<pre>(['value: number'])->BisectingKMeans \n\nsetSeed(%d)\n</pre>\n<hr class=\"solid\">\n<p>[BisectingKMeans]</p>\n<p>Param for random seed.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[BucketedRandomProjectionLSH]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setBucketLength", "detail": "->BucketedRandomProjectionLSH", "apply": "setBucketLength(${\"value: number\"})", "info": "\n<pre>(['value: number'])->BucketedRandomProjectionLSH \n\nsetBucketLength(%f)\n</pre>\n<hr class=\"solid\">\n<p>[BucketedRandomProjectionLSH]</p>\n<p>The length of each hash bucket, a larger bucket lowers the false negative rate.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setInputCol", "detail": "->BucketedRandomProjectionLSH", "apply": "setInputcol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->BucketedRandomProjectionLSH \n\nsetInputcol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[BucketedRandomProjectionLSH]</p>\n<p>Param for input column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setNumHashTables", "detail": "->BucketedRandomProjectionLSH", "apply": "setNumHashTables(${\"value: number\"})", "info": "\n<pre>(['value: number'])->BucketedRandomProjectionLSH \n\nsetNumHashTables(%d)\n</pre>\n<hr class=\"solid\">\n<p>[BucketedRandomProjectionLSH]</p>\n<p>Param for the number of hash tables used in LSH OR-amplification.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setOutputCol", "detail": "->BucketedRandomProjectionLSH", "apply": "setOutputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->BucketedRandomProjectionLSH \n\nsetOutputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[BucketedRandomProjectionLSH]</p>\n<p>Param for output column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSeed", "detail": "->BucketedRandomProjectionLSH", "apply": "setSeed(${\"value: number\"})", "info": "\n<pre>(['value: number'])->BucketedRandomProjectionLSH \n\nsetSeed(%d)\n</pre>\n<hr class=\"solid\">\n<p>[BucketedRandomProjectionLSH]</p>\n<p>Param for random seed.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[ChiSqSelector]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFdr", "detail": "->ChiSqSelector", "apply": "setFdr(${\"value: number\"})", "info": "\n<pre>(['value: number'])->ChiSqSelector \n\nsetFdr(%f)\n</pre>\n<hr class=\"solid\">\n<p>[ChiSqSelector]</p>\n<p>The upper bound of the expected false discovery rate. (Spark 2.2)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->ChiSqSelector", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->ChiSqSelector \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[ChiSqSelector]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFpr", "detail": "->ChiSqSelector", "apply": "setFpr(${\"value: number\"})", "info": "\n<pre>(['value: number'])->ChiSqSelector \n\nsetFpr(%f)\n</pre>\n<hr class=\"solid\">\n<p>[ChiSqSelector]</p>\n<p>The highest p-value for features to be kept. (Spark 2.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFwe", "detail": "->ChiSqSelector", "apply": "setFwe(${\"value: number\"})", "info": "\n<pre>(['value: number'])->ChiSqSelector \n\nsetFwe(%f)\n</pre>\n<hr class=\"solid\">\n<p>[ChiSqSelector]</p>\n<p>The upper bound of the expected family-wise error rate. (Spark 2.2)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLabelCol", "detail": "->ChiSqSelector", "apply": "setLabelCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->ChiSqSelector \n\nsetLabelCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[ChiSqSelector]</p>\n<p>Param for label column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setNumTopFeatures", "detail": "->ChiSqSelector", "apply": "setNumTopFeatures(${\"value: number\"})", "info": "\n<pre>(['value: number'])->ChiSqSelector \n\nsetNumTopFeatures(%d)\n</pre>\n<hr class=\"solid\">\n<p>[ChiSqSelector]</p>\n<p>Number of features that selector will select, ordered by ascending p-value.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setOutputCol", "detail": "->ChiSqSelector", "apply": "setOutputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->ChiSqSelector \n\nsetOutputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[ChiSqSelector]</p>\n<p>Param for output column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPercentile", "detail": "->ChiSqSelector", "apply": "setPercentile(${\"value: number\"})", "info": "\n<pre>(['value: number'])->ChiSqSelector \n\nsetPercentile(%f)\n</pre>\n<hr class=\"solid\">\n<p>[ChiSqSelector]</p>\n<p>Percentile of features that selector will select, ordered by statistics value descending. (Spark 2.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSelectorType", "detail": "->ChiSqSelector", "apply": "setSelectorType(${\"value: string\"})", "info": "\n<pre>(['value: string'])->ChiSqSelector \n\nsetSelectorType(%s)\n</pre>\n<hr class=\"solid\">\n<p>[ChiSqSelector]</p>\n<p>The selector type of the ChisqSelector. (Spark 2.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "as", "detail": "->Column", "apply": "as(${\"alias: string\"} ${2:\"opt_metadata: Metadata(Optional)\"})", "info": "\n<pre>(['alias: string', ' opt_metadata: Metadata'])->Column \n\nas(%s%,?o)\n</pre>\n<hr class=\"solid\">\n<p>[Column]</p>\n<p>Gives the column an alias and optional metadata.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "cast", "detail": "->Column", "apply": "cast(${\"to: string\"})", "info": "\n<pre>(['to: string'])->Column \n\ncast(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Column]</p>\n<p>Casts the column to a different type.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "over", "detail": "->Column", "apply": "over(${\"window: WindowSpec\"})", "info": "\n<pre>(['window: WindowSpec'])->Column \n\nover(%o)\n</pre>\n<hr class=\"solid\">\n<p>[Column]</p>\n<p>Define a windowing column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "equal", "detail": "->Column", "apply": "equalTo(${\"right: Column\"})", "info": "\n<pre>(['right: Column'])->Column \n\nequalTo(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Column]</p>\n<p>Equality test.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "otherwise", "detail": "->Column", "apply": "otherwise(${\"value: Column\"})", "info": "\n<pre>(['value: Column'])->Column \n\notherwise(%c)\n</pre>\n<hr class=\"solid\">\n<p>[ConditionChain]</p>\n<p>Evaluates a list of conditions and returns one of multiple possible result expressions.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "when", "detail": "->ConditionChain", "apply": "when(${\"condition: Column\"}, ${\"value: Column\"})", "info": "\n<pre>(['condition: Column', ' value: Column'])->ConditionChain \n\nwhen(%c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[ConditionChain]</p>\n<p>Evaluates a list of conditions and returns one of multiple possible result expressions.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[CountVectorizer]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setBinary", "detail": "->CountVectorizer", "apply": "setBinary(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->CountVectorizer \n\nsetBinary(%b)\n</pre>\n<hr class=\"solid\">\n<p>[CountVectorizer]</p>\n<p>Binary toggle to control the output vector values. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setInputCol", "detail": "->CountVectorizer", "apply": "setInputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->CountVectorizer \n\nsetInputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[CountVectorizer]</p>\n<p>Param for input column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMinDF", "detail": "->CountVectorizer", "apply": "setMinDF(${\"value: number\"})", "info": "\n<pre>(['value: number'])->CountVectorizer \n\nsetMinDF(%f)\n</pre>\n<hr class=\"solid\">\n<p>[CountVectorizer]</p>\n<p>Specifies the minimum number of different documents a term must appear in to be included in the vocabulary.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMinTF", "detail": "->CountVectorizer", "apply": "setMinTF(${\"value: number\"})", "info": "\n<pre>(['value: number'])->CountVectorizer \n\nsetMinTF(%f)\n</pre>\n<hr class=\"solid\">\n<p>[CountVectorizer]</p>\n<p>Filter to ignore rare words in a document.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setOutputCol", "detail": "->CountVectorizer", "apply": "setOutputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->CountVectorizer \n\nsetOutputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[CountVectorizer]</p>\n<p>Param for output column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setVocabSize", "detail": "->CountVectorizer", "apply": "setVocabSize(${\"value: number\"})", "info": "\n<pre>(['value: number'])->CountVectorizer \n\nsetVocabSize(%d)\n</pre>\n<hr class=\"solid\">\n<p>[CountVectorizer]</p>\n<p>Max size of the vocabulary.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeClassifier]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setCacheNodeIds", "detail": "->DecisionTreeClassifier", "apply": "setCacheNodeIds(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->DecisionTreeClassifier \n\nsetCacheNodeIds(%b)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeClassifier]</p>\n<p>If true, the algorithm will cache node IDs for each instance.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setCheckpointInterval", "detail": "->DecisionTreeClassifier", "apply": "setCheckpointInterval(${\"value: number\"})", "info": "\n<pre>(['value: number'])->DecisionTreeClassifier \n\nsetCheckpointInterval(%d)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeClassifier]</p>\n<p>Param for set checkpoint interval (>= 1) or disable checkpoint (-1).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->DecisionTreeClassifier", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->DecisionTreeClassifier \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeClassifier]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setImpurity", "detail": "->DecisionTreeClassifier", "apply": "setImpurity(${\"value: string\"})", "info": "\n<pre>(['value: string'])->DecisionTreeClassifier \n\nsetImpurity(%s)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeClassifier]</p>\n<p>Criterion used for information gain calculation (case-insensitive).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLabelCol", "detail": "->DecisionTreeClassifier", "apply": "setLabelCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->DecisionTreeClassifier \n\nsetLabelCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeClassifier]</p>\n<p>Param for label column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxBins", "detail": "->DecisionTreeClassifier", "apply": "setMaxBins(${\"value: number\"})", "info": "\n<pre>(['value: number'])->DecisionTreeClassifier \n\nsetMaxBins(%d)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeClassifier]</p>\n<p>Maximum number of bins used for discretizing continuous features and for choosing how to split on features at each node.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxDepth", "detail": "->DecisionTreeClassifier", "apply": "setMaxDepth(${\"value: number\"})", "info": "\n<pre>(['value: number'])->DecisionTreeClassifier \n\nsetMaxDepth(%d)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeClassifier]</p>\n<p>Maximum depth of the tree (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxMemoryInMB", "detail": "->DecisionTreeClassifier", "apply": "setMaxMemoryInMB(${\"value: number\"})", "info": "\n<pre>(['value: number'])->DecisionTreeClassifier \n\nsetMaxMemoryInMB(%d)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeClassifier]</p>\n<p>Maximum memory in MB allocated to histogram aggregation.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMinInfoGain", "detail": "->DecisionTreeClassifier", "apply": "setMinInfoGain(${\"value: number\"})", "info": "\n<pre>(['value: number'])->DecisionTreeClassifier \n\nsetMinInfoGain(%f)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeClassifier]</p>\n<p>Minimum information gain for a split to be considered at a tree node.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMinInstancesPerNode", "detail": "->DecisionTreeClassifier", "apply": "setMinInstancesPerNode(${\"value: number\"})", "info": "\n<pre>(['value: number'])->DecisionTreeClassifier \n\nsetMinInstancesPerNode(%d)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeClassifier]</p>\n<p>Minimum number of instances each child must have after split.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->DecisionTreeClassifier", "apply": "setPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->DecisionTreeClassifier \n\nsetPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeClassifier]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setProbabilityCol", "detail": "->DecisionTreeClassifier", "apply": "setProbabilityCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->DecisionTreeClassifier \n\nsetProbabilityCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeClassifier]</p>\n<p>Param for Column name for predicted class conditional probabilities.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setRawPredictionCol", "detail": "->DecisionTreeClassifier", "apply": "setRawPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->DecisionTreeClassifier \n\nsetRawPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeClassifier]</p>\n<p>Param for raw prediction (a.k.a. confidence) column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSeed", "detail": "->DecisionTreeClassifier", "apply": "setSeed(${\"value: number\"})", "info": "\n<pre>(['value: number'])->DecisionTreeClassifier \n\nsetSeed(%d)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeClassifier]</p>\n<p>Param for random seed. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setThresholds", "detail": "->DecisionTreeClassifier", "apply": "setThresholds(${\"value: [number]\"})", "info": "\n<pre>(['value: [number]'])->DecisionTreeClassifier \n\nsetThresholds(%d)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeClassifier]</p>\n<p>Param for Thresholds in multi-class classification to adjust the probability of predicting each class.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeRegressor]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setCacheNodeIds", "detail": "->DecisionTreeRegressor", "apply": "setCacheNodeIds(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->DecisionTreeRegressor \n\nsetCacheNodeIds(%b)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeRegressor]</p>\n<p>If false, the algorithm will pass trees to executors to match instances with nodes.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setCheckpointInterval", "detail": "->DecisionTreeRegressor", "apply": "setCheckpointInterval(${\"value: number\"})", "info": "\n<pre>(['value: number'])->DecisionTreeRegressor \n\nsetCheckpointInterval(%d)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeRegressor]</p>\n<p>Param for set checkpoint interval (>= 1) or disable checkpoint (-1).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->DecisionTreeRegressor", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->DecisionTreeRegressor \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeRegressor]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setImpurity", "detail": "->DecisionTreeRegressor", "apply": "setImpurity(${\"value: string\"})", "info": "\n<pre>(['value: string'])->DecisionTreeRegressor \n\nsetImpurity(%s)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeRegressor]</p>\n<p>Criterion used for information gain calculation (case-insensitive).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLabelCol", "detail": "->DecisionTreeRegressor", "apply": "setLabelCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->DecisionTreeRegressor \n\nsetLabelCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeRegressor]</p>\n<p>Param for label column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxBins", "detail": "->DecisionTreeRegressor", "apply": "setMaxBins(${\"value: number\"})", "info": "\n<pre>(['value: number'])->DecisionTreeRegressor \n\nsetMaxBins(%d)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeRegressor]</p>\n<p>Maximum number of bins used for discretizing continuous features and for choosing how to split on features at each node.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxDepth", "detail": "->DecisionTreeRegressor", "apply": "setMaxDepth(${\"value: number\"})", "info": "\n<pre>(['value: number'])->DecisionTreeRegressor \n\nsetMaxDepth(%d)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeRegressor]</p>\n<p>Maximum depth of the tree (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxMemoryInMB", "detail": "->DecisionTreeRegressor", "apply": "setMaxMemoryInMB(${\"value: number\"})", "info": "\n<pre>(['value: number'])->DecisionTreeRegressor \n\nsetMaxMemoryInMB(%d)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeRegressor]</p>\n<p>Maximum memory in MB allocated to histogram aggregation.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMinInfoGain", "detail": "->DecisionTreeRegressor", "apply": "setMinInfoGain(${\"value: number\"})", "info": "\n<pre>(['value: number'])->DecisionTreeRegressor \n\nsetMinInfoGain(%f)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeRegressor]</p>\n<p>Minimum information gain for a split to be considered at a tree node.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMinInstancesPerNode", "detail": "->DecisionTreeRegressor", "apply": "setMinInstancesPerNode(${\"value: number\"})", "info": "\n<pre>(['value: number'])->DecisionTreeRegressor \n\nsetMinInstancesPerNode(%d)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeRegressor]</p>\n<p>Minimum number of instances each child must have after split.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->DecisionTreeRegressor", "apply": "setPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->DecisionTreeRegressor \n\nsetPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeRegressor]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSeed", "detail": "->DecisionTreeRegressor", "apply": "setSeed(${\"value: number\"})", "info": "\n<pre>(['value: number'])->DecisionTreeRegressor \n\nsetSeed(%d)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeRegressor]</p>\n<p>Param for random seed. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setVarianceCol", "detail": "->DecisionTreeRegressor", "apply": "setVarianceCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->DecisionTreeRegressor \n\nsetVarianceCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[DecisionTreeRegressor]</p>\n<p>Param for Column name for the biased sample variance of prediction. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[FPGrowth]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setItemsCol", "detail": "->FPGrowth", "apply": "setItemsCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->FPGrowth \n\nsetItemsCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[FPGrowth]</p>\n<p>Items column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMinConfidence", "detail": "->FPGrowth", "apply": "setMinConfidence(${\"value: number\"})", "info": "\n<pre>(['value: number'])->FPGrowth \n\nsetMinConfidence(%f)\n</pre>\n<hr class=\"solid\">\n<p>[FPGrowth]</p>\n<p>Minimal confidence for generating Association Rule.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMinSupport", "detail": "->FPGrowth", "apply": "setMinSupport(${\"value: number\"})", "info": "\n<pre>(['value: number'])->FPGrowth \n\nsetMinSupport(%f)\n</pre>\n<hr class=\"solid\">\n<p>[FPGrowth]</p>\n<p>Minimal support level of the frequent pattern.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setNumPartitions", "detail": "->FPGrowth", "apply": "setNumPartitions(${\"value: number\"})", "info": "\n<pre>(['value: number'])->FPGrowth \n\nsetNumPartitions(%d)\n</pre>\n<hr class=\"solid\">\n<p>[FPGrowth]</p>\n<p>Number of partitions used by parallel FP-growth.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->FPGrowth", "apply": "setPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->FPGrowth \n\nsetPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[FPGrowth]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[GBTClassifier]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setCacheNodeIds", "detail": "->GBTClassifier", "apply": "setCacheNodeIds(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->GBTClassifier \n\nsetCacheNodeIds(%b)\n</pre>\n<hr class=\"solid\">\n<p>[GBTClassifier]</p>\n<p>If false, the algorithm will pass trees to executors to match instances with nodes.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->GBTClassifier", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GBTClassifier \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GBTClassifier]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setImpurity", "detail": "->GBTClassifier", "apply": "setImpurity(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GBTClassifier \n\nsetImpurity(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GBTClassifier]</p>\n<p>Criterion used for information gain calculation (case-insensitive).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLabelCol", "detail": "->GBTClassifier", "apply": "setLabelCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GBTClassifier \n\nsetLabelCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GBTClassifier]</p>\n<p>Param for label column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLossType", "detail": "->GBTClassifier", "apply": "setLossType(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GBTClassifier \n\nsetLossType(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GBTClassifier]</p>\n<p>Loss function which GBT tries to minimize.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxBins", "detail": "->GBTClassifier", "apply": "setMaxBins(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GBTClassifier \n\nsetMaxBins(%d)\n</pre>\n<hr class=\"solid\">\n<p>[GBTClassifier]</p>\n<p>Maximum number of bins used for discretizing continuous features and for choosing how to split on features at each node.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxDepth", "detail": "->GBTClassifier", "apply": "setMaxDepth(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GBTClassifier \n\nsetMaxDepth(%d)\n</pre>\n<hr class=\"solid\">\n<p>[GBTClassifier]</p>\n<p>Maximum depth of the tree (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxIter", "detail": "->GBTClassifier", "apply": "setMaxIter(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GBTClassifier \n\nsetMaxIter(%d)\n</pre>\n<hr class=\"solid\">\n<p>[GBTClassifier]</p>\n<p>Param for maximum number of iterations (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxMemoryInMB", "detail": "->GBTClassifier", "apply": "setMaxMemoryInMB(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GBTClassifier \n\nsetMaxMemoryInMB(%d)\n</pre>\n<hr class=\"solid\">\n<p>[GBTClassifier]</p>\n<p>Maximum memory in MB allocated to histogram aggregation.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMinInfoGain", "detail": "->GBTClassifier", "apply": "setMinInfoGain(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GBTClassifier \n\nsetMinInfoGain(%f)\n</pre>\n<hr class=\"solid\">\n<p>[GBTClassifier]</p>\n<p>Minimum information gain for a split to be considered at a tree node.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMinInstancesPerNode", "detail": "->GBTClassifier", "apply": "setMinInstancesPerNode(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GBTClassifier \n\nsetMinInstancesPerNode(%d)\n</pre>\n<hr class=\"solid\">\n<p>[GBTClassifier]</p>\n<p>Minimum number of instances each child must have after split.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->GBTClassifier", "apply": "setPredicitionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GBTClassifier \n\nsetPredicitionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GBTClassifier]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSeed", "detail": "->GBTClassifier", "apply": "setSeed(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GBTClassifier \n\nsetSeed(%d)\n</pre>\n<hr class=\"solid\">\n<p>[GBTClassifier]</p>\n<p>Param for random seed.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setStepSize", "detail": "->GBTClassifier", "apply": "setStepSize(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GBTClassifier \n\nsetStepSize(%f)\n</pre>\n<hr class=\"solid\">\n<p>[GBTClassifier]</p>\n<p>Param for Step size (a.k.a. learning rate) in interval (0, 1] for shrinking the contribution of each estimator. (default = 0.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSubsamplingRate", "detail": "->GBTClassifier", "apply": "setSubsamplingRate(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GBTClassifier \n\nsetSubsamplingRate(%f)\n</pre>\n<hr class=\"solid\">\n<p>[GBTClassifier]</p>\n<p>Fraction of the training data used for learning each decision tree, in range (0, 1].</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[GBTRegressor]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setCacheNodeIds", "detail": "->GBTRegressor", "apply": "setCacheNodeIds(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->GBTRegressor \n\nsetCacheNodeIds(%b)\n</pre>\n<hr class=\"solid\">\n<p>[GBTRegressor]</p>\n<p>If false, the algorithm will pass trees to executors to match instances with nodes.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setCheckpointInterval", "detail": "->GBTRegressor", "apply": "setCheckpointInterval(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GBTRegressor \n\nsetCheckpointInterval(%d)\n</pre>\n<hr class=\"solid\">\n<p>[GBTRegressor]</p>\n<p>Param for set checkpoint interval (>= 1) or disable checkpoint (-1).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->GBTRegressor", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GBTRegressor \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GBTRegressor]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setImpurity", "detail": "->GBTRegressor", "apply": "setImpurity(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GBTRegressor \n\nsetImpurity(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GBTRegressor]</p>\n<p>Criterion used for information gain calculation (case-insensitive).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLabelCol", "detail": "->GBTRegressor", "apply": "setLabelCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GBTRegressor \n\nsetLabelCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GBTRegressor]</p>\n<p>Param for label column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLossType", "detail": "->GBTRegressor", "apply": "setLossType(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GBTRegressor \n\nsetLossType(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GBTRegressor]</p>\n<p>Loss function which GBT tries to minimize.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxBins", "detail": "->GBTRegressor", "apply": "setMaxBins(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GBTRegressor \n\nsetMaxBins(%d)\n</pre>\n<hr class=\"solid\">\n<p>[GBTRegressor]</p>\n<p>Maximum number of bins used for discretizing continuous features and for choosing how to split on features at each node.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxDepth", "detail": "->GBTRegressor", "apply": "setMaxDepth(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GBTRegressor \n\nsetMaxDepth(%d)\n</pre>\n<hr class=\"solid\">\n<p>[GBTRegressor]</p>\n<p>Maximum depth of the tree (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxIter", "detail": "->GBTRegressor", "apply": "setMaxIter(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GBTRegressor \n\nsetMaxIter(%d)\n</pre>\n<hr class=\"solid\">\n<p>[GBTRegressor]</p>\n<p>Param for maximum number of iterations (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxMemoryInMB", "detail": "->GBTRegressor", "apply": "setMaxMemoryInMB(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GBTRegressor \n\nsetMaxMemoryInMB(%d)\n</pre>\n<hr class=\"solid\">\n<p>[GBTRegressor]</p>\n<p>Maximum memory in MB allocated to histogram aggregation.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMinInfoGain", "detail": "->GBTRegressor", "apply": "setMinInfoGain(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GBTRegressor \n\nsetMinInfoGain(%f)\n</pre>\n<hr class=\"solid\">\n<p>[GBTRegressor]</p>\n<p>Minimum information gain for a split to be considered at a tree node.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMinInstancesPerNode", "detail": "->GBTRegressor", "apply": "setMinInstancesPerNode(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GBTRegressor \n\nsetMinInstancesPerNode(%d)\n</pre>\n<hr class=\"solid\">\n<p>[GBTRegressor]</p>\n<p>Minimum number of instances each child must have after split.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->GBTRegressor", "apply": "setPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GBTRegressor \n\nsetPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GBTRegressor]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSeed", "detail": "->GBTRegressor", "apply": "setSeed(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GBTRegressor \n\nsetSeed(%d)\n</pre>\n<hr class=\"solid\">\n<p>[GBTRegressor]</p>\n<p>Param for random seed.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setStepSize", "detail": "->GBTRegressor", "apply": "setStepSize(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GBTRegressor \n\nsetStepSize(%f)\n</pre>\n<hr class=\"solid\">\n<p>[GBTRegressor]</p>\n<p>Param for Step size (a.k.a. learning rate) in interval (0, 1] for shrinking the contribution of each estimator. (default = 0.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSubsamplingRate", "detail": "->GBTRegressor", "apply": "setSubsamplingRate(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GBTRegressor \n\nsetSubsamplingRate(%f)\n</pre>\n<hr class=\"solid\">\n<p>[GBTRegressor]</p>\n<p>Fraction of the training data used for learning each decision tree, in range (0, 1].</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[GeneralizedLinearRegression]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFamily", "detail": "->GeneralizedLinearRegression", "apply": "setFamily(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GeneralizedLinearRegression \n\nsetFamily(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GeneralizedLinearRegression]</p>\n<p>Param for the name of family which is a description of the error distribution to be used in the model.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->GeneralizedLinearRegression", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GeneralizedLinearRegression \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GeneralizedLinearRegression]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFitIntercept", "detail": "->GeneralizedLinearRegression", "apply": "setFitIntercept(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->GeneralizedLinearRegression \n\nsetFitIntercept(%b)\n</pre>\n<hr class=\"solid\">\n<p>[GeneralizedLinearRegression]</p>\n<p>Param for whether to fit an intercept term.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLabelCol", "detail": "->GeneralizedLinearRegression", "apply": "setLabelCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GeneralizedLinearRegression \n\nsetLabelCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GeneralizedLinearRegression]</p>\n<p>Param for label column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLink", "detail": "->GeneralizedLinearRegression", "apply": "setLink(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GeneralizedLinearRegression \n\nsetLink(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GeneralizedLinearRegression]</p>\n<p>Param for the name of link function which provides the relationship between the linear predictor and the mean of the distribution function.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLinkPower", "detail": "->GeneralizedLinearRegression", "apply": "setLinkPower(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GeneralizedLinearRegression \n\nsetLinkPower(%f)\n</pre>\n<hr class=\"solid\">\n<p>[GeneralizedLinearRegression]</p>\n<p>Param for the index in the power link function. (Spark 2.2)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLinkPredictionCol", "detail": "->GeneralizedLinearRegression", "apply": "setLinkPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GeneralizedLinearRegression \n\nsetLinkPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GeneralizedLinearRegression]</p>\n<p>Param for link prediction (linear predictor) column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxIter", "detail": "->GeneralizedLinearRegression", "apply": "setMaxIter(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GeneralizedLinearRegression \n\nsetMaxIter(%d)\n</pre>\n<hr class=\"solid\">\n<p>[GeneralizedLinearRegression]</p>\n<p>Param for maximum number of iterations (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->GeneralizedLinearRegression", "apply": "setPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GeneralizedLinearRegression \n\nsetPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GeneralizedLinearRegression]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setRegParam", "detail": "->GeneralizedLinearRegression", "apply": "setRegParam(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GeneralizedLinearRegression \n\nsetRegParam(%f)\n</pre>\n<hr class=\"solid\">\n<p>[GeneralizedLinearRegression]</p>\n<p>Param for regularization parameter (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSolver", "detail": "->GeneralizedLinearRegression", "apply": "setSolver(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GeneralizedLinearRegression \n\nsetSolver(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GeneralizedLinearRegression]</p>\n<p>Param for the solver algorithm for optimization.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setTol", "detail": "->GeneralizedLinearRegression", "apply": "setTol(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GeneralizedLinearRegression \n\nsetTol(%f)\n</pre>\n<hr class=\"solid\">\n<p>[GeneralizedLinearRegression]</p>\n<p>Param for the convergence tolerance for iterative algorithms (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setVariancePower", "detail": "->GeneralizedLinearRegression", "apply": "setVariancePower(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GeneralizedLinearRegression \n\nsetVariancePower(%f)\n</pre>\n<hr class=\"solid\">\n<p>[GeneralizedLinearRegression]</p>\n<p>Param for the power in the variance function of the Tweedie distribution which provides the relationship between the variance and mean of the distribution. (Spark 2.2)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setWeightCol", "detail": "->GeneralizedLinearRegression", "apply": "setWeightCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GeneralizedLinearRegression \n\nsetWeightCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GeneralizedLinearRegression]</p>\n<p>Param for weight column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "agg", "detail": "->DataFrame", "apply": "agg(${\"expr1: Column\"}%,*c)", "info": "\n<pre>(['expr1: Column', ' exprs_varargs: Column'])->DataFrame \n\nagg(%c%,*c)\n</pre>\n<hr class=\"solid\">\n<p>[GroupedData]</p>\n<p>Compute aggregates by specifying a series of aggregate columns.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "avg", "detail": "->DataFrame", "apply": "avg(${\"colNames_varargs: string(Vararg)\"})", "info": "\n<pre>(['colNames_varargs: string'])->DataFrame \n\navg(%*s)\n</pre>\n<hr class=\"solid\">\n<p>[GroupedData]</p>\n<p>Compute the mean value for each numeric columns for each group.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "count", "detail": "->DataFrame", "apply": "count()", "info": "\n<pre>([''])->DataFrame \n\ncount()\n</pre>\n<hr class=\"solid\">\n<p>[GroupedData]</p>\n<p>Count the number of rows for each group.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "max", "detail": "->DataFrame", "apply": "max(${\"colNames_varargs: string(Vararg)\"})", "info": "\n<pre>(['colNames_varargs: string'])->DataFrame \n\nmax(%*s)\n</pre>\n<hr class=\"solid\">\n<p>[GroupedData]</p>\n<p>Compute the max value for each numeric columns for each group.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "mean", "detail": "->DataFrame", "apply": "mean(${\"colNames_varargs: string(Vararg)\"})", "info": "\n<pre>(['colNames_varargs: string'])->DataFrame \n\nmean(%*s)\n</pre>\n<hr class=\"solid\">\n<p>[GroupedData]</p>\n<p>Compute the average value for each numeric columns for each group.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "min", "detail": "->DataFrame", "apply": "min(${\"colNames_varargs: string(Vararg)\"})", "info": "\n<pre>(['colNames_varargs: string'])->DataFrame \n\nmin(%*s)\n</pre>\n<hr class=\"solid\">\n<p>[GroupedData]</p>\n<p>Compute the min value for each numeric column for each group.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "pivot", "detail": "->GroupedData", "apply": "pivot(${\"pivotColumn: string\"})", "info": "\n<pre>(['pivotColumn: string'])->GroupedData \n\npivot(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GroupedData]</p>\n<p>Pivots a column of the current DataFrame and perform the specified aggregation. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "sum", "detail": "->DataFrame", "apply": "sum(${\"colNames_varargs: string(Vararg)\"})", "info": "\n<pre>(['colNames_varargs: string'])->DataFrame \n\nsum(%*s)\n</pre>\n<hr class=\"solid\">\n<p>[GroupedData]</p>\n<p>Compute the sum for each numeric columns for each group.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[GaussianMixture]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->GaussianMixture", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GaussianMixture \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GaussianMixture]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setK", "detail": "->GaussianMixture", "apply": "setK(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GaussianMixture \n\nsetK(%d)\n</pre>\n<hr class=\"solid\">\n<p>[GaussianMixture]</p>\n<p>Number of independent Gaussians in the mixture model.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxIter", "detail": "->GaussianMixture", "apply": "setMaxIter(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GaussianMixture \n\nsetMaxIter(%d)\n</pre>\n<hr class=\"solid\">\n<p>[GaussianMixture]</p>\n<p>Param for maximum number of iterations (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->GaussianMixture", "apply": "setPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GaussianMixture \n\nsetPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GaussianMixture]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setProbabilityCol", "detail": "->GaussianMixture", "apply": "setProbabilityCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->GaussianMixture \n\nsetProbabilityCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[GaussianMixture]</p>\n<p>Param for Column name for predicted class conditional probabilities.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSeed", "detail": "->GaussianMixture", "apply": "setSeed(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GaussianMixture \n\nsetSeed(%d)\n</pre>\n<hr class=\"solid\">\n<p>[GaussianMixture]</p>\n<p>Param for random seed.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setTol", "detail": "->GaussianMixture", "apply": "setTol(${\"value: number\"})", "info": "\n<pre>(['value: number'])->GaussianMixture \n\nsetTol(%f)\n</pre>\n<hr class=\"solid\">\n<p>[GaussianMixture]</p>\n<p>Param for the convergence tolerance for iterative algorithms (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[IDF]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setInputCol", "detail": "->IDF", "apply": "setInputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->IDF \n\nsetInputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[IDF]</p>\n<p>Param for input column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMinDocFreq", "detail": "->IDF", "apply": "setMinDocFreq(${\"value: number\"})", "info": "\n<pre>(['value: number'])->IDF \n\nsetMinDocFreq(%d)\n</pre>\n<hr class=\"solid\">\n<p>[IDF]</p>\n<p>The minimum number of documents in which a term should appear.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setOutputCol", "detail": "->IDF", "apply": "setOutputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->IDF \n\nsetOutputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[IDF]</p>\n<p>Param for output column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[Imputer]</p>\n<p>Fits a model to the inptu data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setInputCols", "detail": "->Imputer", "apply": "setInputCols(${\"value: [string](Array)\"})", "info": "\n<pre>(['value: [string]'])->Imputer \n\nsetInputCols(%@s)\n</pre>\n<hr class=\"solid\">\n<p>[Imputer]</p>\n<p>Param for input column names.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMissingValue", "detail": "->Imputer", "apply": "setMissingValue(${\"value: number\"})", "info": "\n<pre>(['value: number'])->Imputer \n\nsetMissingValue(%f)\n</pre>\n<hr class=\"solid\">\n<p>[Imputer]</p>\n<p>The placeholder for the missing values.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setOutputCols", "detail": "->Imputer", "apply": "setOutputCols(${\"value: [string](Array)\"})", "info": "\n<pre>(['value: [string]'])->Imputer \n\nsetOutputCols(%@s)\n</pre>\n<hr class=\"solid\">\n<p>[Imputer]</p>\n<p>Param for output column names.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setStrategy", "detail": "->Imputer", "apply": "setStrategy(${\"value: string\"})", "info": "\n<pre>(['value: string'])->Imputer \n\nsetStrategy(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Imputer]</p>\n<p>The imputation strategy.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[IsotonicRegression]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeatureIndex", "detail": "->IsotonicRegression", "apply": "setFeatureIndex(${\"value: number\"})", "info": "\n<pre>(['value: number'])->IsotonicRegression \n\nsetFeatureIndex(%d)\n</pre>\n<hr class=\"solid\">\n<p>[IsotonicRegression]</p>\n<p>Param for the index of the feature if featuresCol is a vector column (default: 0), no effect otherwise.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->IsotonicRegression", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->IsotonicRegression \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[IsotonicRegression]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setIsotonic", "detail": "->IsotonicRegression", "apply": "setIsotonic(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->IsotonicRegression \n\nsetIsotonic(%b)\n</pre>\n<hr class=\"solid\">\n<p>[IsotonicRegression]</p>\n<p>Param for whether the output sequence should be isotonic/increasing (true) or antitonic/decreasing (false).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLabelCol", "detail": "->IsotonicRegression", "apply": "setLabelCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->IsotonicRegression \n\nsetLabelCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[IsotonicRegression]</p>\n<p>Param for label column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->IsotonicRegression", "apply": "setPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->IsotonicRegression \n\nsetPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[IsotonicRegression]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setWeightCol", "detail": "->IsotonicRegression", "apply": "setWeightCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->IsotonicRegression \n\nsetWeightCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[IsotonicRegression]</p>\n<p>Param for weight column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[KMeans]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->KMeans", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->KMeans \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[KMeans]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setInitMode", "detail": "->KMeans", "apply": "setInitMode(${\"value: string\"})", "info": "\n<pre>(['value: string'])->KMeans \n\nsetInitMode(%s)\n</pre>\n<hr class=\"solid\">\n<p>[KMeans]</p>\n<p>Param for the initialization algorithm.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setInitSteps", "detail": "->KMeans", "apply": "setInitSteps(${\"value: number\"})", "info": "\n<pre>(['value: number'])->KMeans \n\nsetInitSteps(%d)\n</pre>\n<hr class=\"solid\">\n<p>[KMeans]</p>\n<p>Param for the number of steps for the k-means initialization mode.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setK", "detail": "->KMeans", "apply": "setK(${\"value: number\"})", "info": "\n<pre>(['value: number'])->KMeans \n\nsetK(%d)\n</pre>\n<hr class=\"solid\">\n<p>[KMeans]</p>\n<p>The number of clusters to create (k).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxIter", "detail": "->KMeans", "apply": "setMaxIter(${\"value: number\"})", "info": "\n<pre>(['value: number'])->KMeans \n\nsetMaxIter(%d)\n</pre>\n<hr class=\"solid\">\n<p>[KMeans]</p>\n<p>Param for maximum number of iterations (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->KMeans", "apply": "setPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->KMeans \n\nsetPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[KMeans]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSeed", "detail": "->KMeans", "apply": "setSeed(${\"value: number\"})", "info": "\n<pre>(['value: number'])->KMeans \n\nsetSeed(%d)\n</pre>\n<hr class=\"solid\">\n<p>[KMeans]</p>\n<p>Param for random seed.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setTol", "detail": "->KMeans", "apply": "setTol(${\"value: number\"})", "info": "\n<pre>(['value: number'])->KMeans \n\nsetTol(%f)\n</pre>\n<hr class=\"solid\">\n<p>[KMeans]</p>\n<p>Param for the convergence tolerance for iterative algorithms (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[LDA]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setCheckpointInterval", "detail": "->LDA", "apply": "setCheckpointInterval(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LDA \n\nsetCheckpointInterval(%d)\n</pre>\n<hr class=\"solid\">\n<p>[LDA]</p>\n<p>Param for set checkpoint interval (>= 1) or disable checkpoint (-1).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setDocConcentration", "detail": "->LDA", "apply": "setDocConcentration(${\"value: [number]\"})", "info": "\n<pre>(['value: [number]'])->LDA \n\nsetDocConcentration(%f)\n</pre>\n<hr class=\"solid\">\n<p>[LDA]</p>\n<p>Concentration parameter (commonly named \"alpha\") for the prior placed on documents' distributions over topics (\"theta\").</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->LDA", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->LDA \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[LDA]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setK", "detail": "->LDA", "apply": "setK(value: number)", "info": "\n<pre>(['value: number'])->LDA \n\nsetK(value: number)\n</pre>\n<hr class=\"solid\">\n<p>[LDA]</p>\n<p>Param for the number of topics (clusters) to infer.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setKeepLastCheckpoint", "detail": "->LDA", "apply": "setKeepLastCheckpoint(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->LDA \n\nsetKeepLastCheckpoint(%b)\n</pre>\n<hr class=\"solid\">\n<p>[LDA]</p>\n<p>If using checkpointing, this indicates whether to keep the last checkpoint. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLearningDecay", "detail": "->LDA", "apply": "setLearningDecay(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LDA \n\nsetLearningDecay(%f)\n</pre>\n<hr class=\"solid\">\n<p>[LDA]</p>\n<p>Learning rate, set as an exponential decay rate.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLearningOffset", "detail": "->LDA", "apply": "setLearningOffset(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LDA \n\nsetLearningOffset(%f)\n</pre>\n<hr class=\"solid\">\n<p>[LDA]</p>\n<p>A (positive) learning parameter that downweights early iterations.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxIter", "detail": "->LDA", "apply": "setMaxIter(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LDA \n\nsetMaxIter(%d)\n</pre>\n<hr class=\"solid\">\n<p>[LDA]</p>\n<p>Param for maximum number of iterations (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setOptimizeDocConcentration", "detail": "->LDA", "apply": "setOptimizeDocConcentration(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->LDA \n\nsetOptimizeDocConcentration(%b)\n</pre>\n<hr class=\"solid\">\n<p>[LDA]</p>\n<p>Indicates whether the docConcentration will be optimized during training.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setOptimizer", "detail": "->LDA", "apply": "setOptimizer(${\"value: string\"})", "info": "\n<pre>(['value: string'])->LDA \n\nsetOptimizer(%s)\n</pre>\n<hr class=\"solid\">\n<p>[LDA]</p>\n<p>Optimizer or inference algorithm used to estimate the LDA model.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSeed", "detail": "->LDA", "apply": "setSeed(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LDA \n\nsetSeed(%d)\n</pre>\n<hr class=\"solid\">\n<p>[LDA]</p>\n<p>Param for random seed.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSubsamplingRate", "detail": "->LDA", "apply": "setSubsamplingRate(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LDA \n\nsetSubsamplingRate(%f)\n</pre>\n<hr class=\"solid\">\n<p>[LDA]</p>\n<p>Fraction of the corpus to be sampled and used in each iteration of mini-batch gradient descent, in range (0, 1].</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setTopicConcentration", "detail": "->LDA", "apply": "setTopicConcentration(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LDA \n\nsetTopicConcentration(%f)\n</pre>\n<hr class=\"solid\">\n<p>[LDA]</p>\n<p>Concentration parameter (commonly named \"beta\" or \"eta\") for the prior placed on topics' distributions over terms.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setTopicDistributionCol", "detail": "->LDA", "apply": "setTopicDistributionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->LDA \n\nsetTopicDistributionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[LDA]</p>\n<p>Output column with estimates of the topic mixture distribution for each document (often called \"theta\" in the literature).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[LinearRegression]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setAggregationDepth", "detail": "->LinearRegression", "apply": "setAggregationDepth(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LinearRegression \n\nsetAggregationDepth(%d)\n</pre>\n<hr class=\"solid\">\n<p>[LinearRegression]</p>\n<p>Suggested depth for treeAggregate. (Spark 2.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setElasticNetParam", "detail": "->LinearRegression", "apply": "setElasticNetParam(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LinearRegression \n\nsetElasticNetParam(%f)\n</pre>\n<hr class=\"solid\">\n<p>[LinearRegression]</p>\n<p>Param for the ElasticNet mixing parameter, in range [0, 1].</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->LinearRegression", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->LinearRegression \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[LinearRegression]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFitIntercept", "detail": "->LinearRegression", "apply": "setFitIntercept(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->LinearRegression \n\nsetFitIntercept(%b)\n</pre>\n<hr class=\"solid\">\n<p>[LinearRegression]</p>\n<p>Param for whether to fit an intercept term.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLabelCol", "detail": "->LinearRegression", "apply": "setLabelCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->LinearRegression \n\nsetLabelCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[LinearRegression]</p>\n<p>Param for label column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxIter", "detail": "->LinearRegression", "apply": "setMaxIter(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LinearRegression \n\nsetMaxIter(%d)\n</pre>\n<hr class=\"solid\">\n<p>[LinearRegression]</p>\n<p>Param for maximum number of iterations (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->LinearRegression", "apply": "setPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->LinearRegression \n\nsetPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[LinearRegression]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setRegParam", "detail": "->LinearRegression", "apply": "setRegParam(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LinearRegression \n\nsetRegParam(%f)\n</pre>\n<hr class=\"solid\">\n<p>[LinearRegression]</p>\n<p>Param for regularization parameter (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSolver", "detail": "->LinearRegression", "apply": "setSolver(${\"value: string\"})", "info": "\n<pre>(['value: string'])->LinearRegression \n\nsetSolver(%s)\n</pre>\n<hr class=\"solid\">\n<p>[LinearRegression]</p>\n<p>Param for the solver algorithm for optimization. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setStandardization", "detail": "->LinearRegression", "apply": "setStandardization(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->LinearRegression \n\nsetStandardization(%b)\n</pre>\n<hr class=\"solid\">\n<p>[LinearRegression]</p>\n<p>Param for whether to standardize the training features before fitting the model.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setTol", "detail": "->LinearRegression", "apply": "setTol(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LinearRegression \n\nsetTol(%f)\n</pre>\n<hr class=\"solid\">\n<p>[LinearRegression]</p>\n<p>Param for the convergence tolerance for iterative algorithms (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setWeightCol", "detail": "->LinearRegression", "apply": "setWeightCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->LinearRegression \n\nsetWeightCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[LinearRegression]</p>\n<p>Param for weight column name. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[LinearSVC]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setAggregationDepth", "detail": "->LinearSVC", "apply": "setAggregationDepth(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LinearSVC \n\nsetAggregationDepth(%d)\n</pre>\n<hr class=\"solid\">\n<p>[LinearSVC]</p>\n<p>Suggested depth for treeAggregate (greater than or equal to 2).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->LinearSVC", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->LinearSVC \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[LinearSVC]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFitIntercept", "detail": "->LinearSVC", "apply": "setFitIntercept(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->LinearSVC \n\nsetFitIntercept(%b)\n</pre>\n<hr class=\"solid\">\n<p>[LinearSVC]</p>\n<p>Whether to fit an intercept term.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLabelCol", "detail": "->LinearSVC", "apply": "setLabelCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->LinearSVC \n\nsetLabelCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[LinearSVC]</p>\n<p>Param for label column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxIter", "detail": "->LinearSVC", "apply": "setMaxIter(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LinearSVC \n\nsetMaxIter(%d)\n</pre>\n<hr class=\"solid\">\n<p>[LinearSVC]</p>\n<p>Set the maximum number of iterations.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->LinearSVC", "apply": "setPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->LinearSVC \n\nsetPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[LinearSVC]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setRawPredictionCol", "detail": "->LinearSVC", "apply": "setRawPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->LinearSVC \n\nsetRawPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[LinearSVC]</p>\n<p>Param for raw prediction (a.k.a. confidence) column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setRegParam", "detail": "->LinearSVC", "apply": "setRegParam(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LinearSVC \n\nsetRegParam(%f)\n</pre>\n<hr class=\"solid\">\n<p>[LinearSVC]</p>\n<p>Set the regularization parameter.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setStandardization", "detail": "->LinearSVC", "apply": "setStandardization(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->LinearSVC \n\nsetStandardization(%b)\n</pre>\n<hr class=\"solid\">\n<p>[LinearSVC]</p>\n<p>Whether to standardize the training features before fitting the model.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setThreshold", "detail": "->LinearSVC", "apply": "setThreshold(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LinearSVC \n\nsetThreshold(%f)\n</pre>\n<hr class=\"solid\">\n<p>[LinearSVC]</p>\n<p>Set threshold in binary classification.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setTol", "detail": "->LinearSVC", "apply": "setTol(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LinearSVC \n\nsetTol(%f)\n</pre>\n<hr class=\"solid\">\n<p>[LinearSVC]</p>\n<p>Set the convergence tolerance of iterations.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setWeightCol", "detail": "->LinearSVC", "apply": "setWeightCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->LinearSVC \n\nsetWeightCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[LinearSVC]</p>\n<p>Param for weight column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[LogisticRegression]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setAggregationDepth", "detail": "->LogisticRegression", "apply": "setAggregationDepth(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LogisticRegression \n\nsetAggregationDepth(%d)\n</pre>\n<hr class=\"solid\">\n<p>[LogisticRegression]</p>\n<p>Suggested depth for treeAggregate (greater than or equal to 2).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setElasticNetParam", "detail": "->LogisticRegression", "apply": "setElasticNetParam(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LogisticRegression \n\nsetElasticNetParam(%f)\n</pre>\n<hr class=\"solid\">\n<p>[LogisticRegression]</p>\n<p>Param for the ElasticNet mixing parameter, in range [0, 1].</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFamily", "detail": "->LogisticRegression", "apply": "setFamily(${\"value: string\"})", "info": "\n<pre>(['value: string'])->LogisticRegression \n\nsetFamily(%s)\n</pre>\n<hr class=\"solid\">\n<p>[LogisticRegression]</p>\n<p>Param for the name of family which is a description of the label distribution to be used in the model. (Spark 2.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->LogisticRegression", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->LogisticRegression \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[LogisticRegression]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFitIntercept", "detail": "->LogisticRegression", "apply": "setFitIntercept(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->LogisticRegression \n\nsetFitIntercept(%b)\n</pre>\n<hr class=\"solid\">\n<p>[LogisticRegression]</p>\n<p>Param for whether to fit an intercept term.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLabelCol", "detail": "->LogisticRegression", "apply": "setLabelCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->LogisticRegression \n\nsetLabelCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[LogisticRegression]</p>\n<p>Param for label column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxIter", "detail": "->LogisticRegression", "apply": "setMaxIter(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LogisticRegression \n\nsetMaxIter(%d)\n</pre>\n<hr class=\"solid\">\n<p>[LogisticRegression]</p>\n<p>Param for maximum number of iterations (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->LogisticRegression", "apply": "setPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->LogisticRegression \n\nsetPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[LogisticRegression]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setProbabilityCol", "detail": "->LogisticRegression", "apply": "setProbabilityCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->LogisticRegression \n\nsetProbabilityCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[LogisticRegression]</p>\n<p>Param for Column name for predicted class conditional probabilities.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setRawPredictionCol", "detail": "->LogisticRegression", "apply": "setRawPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->LogisticRegression \n\nsetRawPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[LogisticRegression]</p>\n<p>Param for raw prediction (a.k.a. confidence) column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setRegParam", "detail": "->LogisticRegression", "apply": "setRegParam(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LogisticRegression \n\nsetRegParam(%f)\n</pre>\n<hr class=\"solid\">\n<p>[LogisticRegression]</p>\n<p>Param for regularization parameter (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setStandardization", "detail": "->LogisticRegression", "apply": "setStandardization(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->LogisticRegression \n\nsetStandardization(%b)\n</pre>\n<hr class=\"solid\">\n<p>[LogisticRegression]</p>\n<p>Whether to standardize the training features before fitting the model.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setThreshold", "detail": "->LogisticRegression", "apply": "setThreshold(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LogisticRegression \n\nsetThreshold(%f)\n</pre>\n<hr class=\"solid\">\n<p>[LogisticRegression]</p>\n<p>Set the threshold in binary classification, in range [0, 1].</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setThresholds", "detail": "->LogisticRegression", "apply": "setThresholds(${\"value: [number](Array)\"})", "info": "\n<pre>(['value: [number]'])->LogisticRegression \n\nsetThresholds(%@f)\n</pre>\n<hr class=\"solid\">\n<p>[LogisticRegression]</p>\n<p>Sets thresholds in multiclass (or binary) classification to adjust the probability of predicting each class.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setTol", "detail": "->LogisticRegression", "apply": "setTol(${\"value: number\"})", "info": "\n<pre>(['value: number'])->LogisticRegression \n\nsetTol(%f)\n</pre>\n<hr class=\"solid\">\n<p>[LogisticRegression]</p>\n<p>Set the convergence tolerance of iterations.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setWeightCol", "detail": "->LogisticRegression", "apply": "setWeightCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->LogisticRegression \n\nsetWeightCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[LogisticRegression]</p>\n<p>Whether to over-/under-sample training instances according to the given weights in weightCol. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[MaxAbsScaler]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setInputCol", "detail": "->MaxAbsScaler", "apply": "setInputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->MaxAbsScaler \n\nsetInputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[MaxAbsScaler]</p>\n<p>Param for input column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setOutputCol", "detail": "->MaxAbsScaler", "apply": "setOutputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->MaxAbsScaler \n\nsetOutputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[MaxAbsScaler]</p>\n<p>Param for output column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[MinHashLSH]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setInputCol", "detail": "->MinHashLSH", "apply": "setInputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->MinHashLSH \n\nsetInputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[MinHashLSH]</p>\n<p>Param for input column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setNumHashTables", "detail": "->MinHashLSH", "apply": "setNumHashTables(${\"value: number\"})", "info": "\n<pre>(['value: number'])->MinHashLSH \n\nsetNumHashTables(%d)\n</pre>\n<hr class=\"solid\">\n<p>[MinHashLSH]</p>\n<p>Param for the number of hash tables used in LSH OR-amplification.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setOutputCol", "detail": "->MinHashLSH", "apply": "setOutputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->MinHashLSH \n\nsetOutputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[MinHashLSH]</p>\n<p>Param for output column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSeed", "detail": "->MinHashLSH", "apply": "setSeed(${\"value: number\"})", "info": "\n<pre>(['value: number'])->MinHashLSH \n\nsetSeed(%d)\n</pre>\n<hr class=\"solid\">\n<p>[MinHashLSH]</p>\n<p>Param for random seed.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[MinMaxScaler]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setInputCol", "detail": "->MinMaxScaler", "apply": "setInputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->MinMaxScaler \n\nsetInputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[MinMaxScaler]</p>\n<p>Param for input column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMax", "detail": "->MinMaxScaler", "apply": "setMax(${\"value: number\"})", "info": "\n<pre>(['value: number'])->MinMaxScaler \n\nsetMax(%f)\n</pre>\n<hr class=\"solid\">\n<p>[MinMaxScaler]</p>\n<p>Upper bound after transformation, shared by all features Default: 1.0</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMin", "detail": "->MinMaxScaler", "apply": "setMin(${\"value: number\"})", "info": "\n<pre>(['value: number'])->MinMaxScaler \n\nsetMin(%f)\n</pre>\n<hr class=\"solid\">\n<p>[MinMaxScaler]</p>\n<p>Lower bound after transformation, shared by all features Default: 0.0</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setOutputCol", "detail": "->MinMaxScaler", "apply": "setOutputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->MinMaxScaler \n\nsetOutputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[MinMaxScaler]</p>\n<p>Param for output column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[MultilayerPerceptronClassifier]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setBlockSize", "detail": "->MultilayerPerceptronClassifier", "apply": "setBlockSize(${\"value: number\"})", "info": "\n<pre>(['value: number'])->MultilayerPerceptronClassifier \n\nsetBlockSize(%d)\n</pre>\n<hr class=\"solid\">\n<p>[MultilayerPerceptronClassifier]</p>\n<p>Block size for stacking input data in matrices to speed up the computation.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->MultilayerPerceptronClassifier", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->MultilayerPerceptronClassifier \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[MultilayerPerceptronClassifier]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setInitialWeights", "detail": "->MultilayerPerceptronClassifier", "apply": "setInitialWeights(${\"value: Vector\"})", "info": "\n<pre>(['value: Vector'])->MultilayerPerceptronClassifier \n\nsetInitialWeights(%o)\n</pre>\n<hr class=\"solid\">\n<p>[MultilayerPerceptronClassifier]</p>\n<p>The initial weights of the model. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLabelCol", "detail": "->MultilayerPerceptronClassifier", "apply": "setLabelCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->MultilayerPerceptronClassifier \n\nsetLabelCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[MultilayerPerceptronClassifier]</p>\n<p>Param for label column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLayers", "detail": "->MultilayerPerceptronClassifier", "apply": "setLayers(${\"value: [number](Array)\"})", "info": "\n<pre>(['value: [number]'])->MultilayerPerceptronClassifier \n\nsetLayers(%@d)\n</pre>\n<hr class=\"solid\">\n<p>[MultilayerPerceptronClassifier]</p>\n<p>Layer sizes including input size and output size.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxIter", "detail": "->MultilayerPerceptronClassifier", "apply": "setMaxIter(${\"value: number\"})", "info": "\n<pre>(['value: number'])->MultilayerPerceptronClassifier \n\nsetMaxIter(%d)\n</pre>\n<hr class=\"solid\">\n<p>[MultilayerPerceptronClassifier]</p>\n<p>Param for maximum number of iterations (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->MultilayerPerceptronClassifier", "apply": "setPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->MultilayerPerceptronClassifier \n\nsetPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[MultilayerPerceptronClassifier]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSeed", "detail": "->MultilayerPerceptronClassifier", "apply": "setSeed(${\"value: number\"})", "info": "\n<pre>(['value: number'])->MultilayerPerceptronClassifier \n\nsetSeed(%d)\n</pre>\n<hr class=\"solid\">\n<p>[MultilayerPerceptronClassifier]</p>\n<p>Set the seed for weights initialization if weights are not set.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSolver", "detail": "->MultilayerPerceptronClassifier", "apply": "setSolver(${\"value: string\"})", "info": "\n<pre>(['value: string'])->MultilayerPerceptronClassifier \n\nsetSolver(%s)\n</pre>\n<hr class=\"solid\">\n<p>[MultilayerPerceptronClassifier]</p>\n<p>The solver algorithm for optimization. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setStepSize", "detail": "->MultilayerPerceptronClassifier", "apply": "setStepSize(${\"value: number\"})", "info": "\n<pre>(['value: number'])->MultilayerPerceptronClassifier \n\nsetStepSize(%f)\n</pre>\n<hr class=\"solid\">\n<p>[MultilayerPerceptronClassifier]</p>\n<p>Param for Step size to be used for each iteration of optimization (> 0). (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setTol", "detail": "->MultilayerPerceptronClassifier", "apply": "setTol(${\"value: number\"})", "info": "\n<pre>(['value: number'])->MultilayerPerceptronClassifier \n\nsetTol(%f)\n</pre>\n<hr class=\"solid\">\n<p>[MultilayerPerceptronClassifier]</p>\n<p>Set the convergence tolerance of iterations (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[NaiveBayes]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->NaiveBayes", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->NaiveBayes \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[NaiveBayes]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLabelCol", "detail": "->NaiveBayes", "apply": "setLabelCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->NaiveBayes \n\nsetLabelCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[NaiveBayes]</p>\n<p>Param for label column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setModelType", "detail": "->NaiveBayes", "apply": "setModelType(${\"value: string\"})", "info": "\n<pre>(['value: string'])->NaiveBayes \n\nsetModelType(%s)\n</pre>\n<hr class=\"solid\">\n<p>[NaiveBayes]</p>\n<p>Set the model type using a string (case-sensitive).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->NaiveBayes", "apply": "setPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->NaiveBayes \n\nsetPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[NaiveBayes]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setProbabilityCol", "detail": "->NaiveBayes", "apply": "setProbabilityCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->NaiveBayes \n\nsetProbabilityCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[NaiveBayes]</p>\n<p>Param for Column name for predicted class conditional probabilities.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setRawPredictionCol", "detail": "->NaiveBayes", "apply": "setRawPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->NaiveBayes \n\nsetRawPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[NaiveBayes]</p>\n<p>Param for raw prediction (a.k.a. confidence) column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSmoothing", "detail": "->NaiveBayes", "apply": "setSmoothing(${\"value: number\"})", "info": "\n<pre>(['value: number'])->NaiveBayes \n\nsetSmoothing(%f)\n</pre>\n<hr class=\"solid\">\n<p>[NaiveBayes]</p>\n<p>Set the smoothing parameter.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setThresholds", "detail": "->NaiveBayes", "apply": "setThresholds(${\"value: [number](Array)\"})", "info": "\n<pre>(['value: [number]'])->NaiveBayes \n\nsetThresholds(%@f)\n</pre>\n<hr class=\"solid\">\n<p>[NaiveBayes]</p>\n<p>Param for Thresholds in multi-class classification to adjust the probability of predicting each class.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setWeightCol", "detail": "->NaiveBayes", "apply": "setWeightCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->NaiveBayes \n\nsetWeightCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[NaiveBayes]</p>\n<p>Param for weight column name. If this is not set or empty, we treat all instance weights as 1.0. (Spark 2.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[OneVsRest]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setClassifier", "detail": "->OneVsRest", "apply": "setClassifier(${\"value: Classifier\"})", "info": "\n<pre>(['value: Classifier'])->OneVsRest \n\nsetClassifier(%o)\n</pre>\n<hr class=\"solid\">\n<p>[OneVsRest]</p>\n<p>Param for the base binary classifier that we reduce multiclass classification into.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->OneVsRest", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->OneVsRest \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[OneVsRest]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLabelCol", "detail": "->OneVsRest", "apply": "setLabelCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->OneVsRest \n\nsetLabelCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[OneVsRest]</p>\n<p>Param for label column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->OneVsRest", "apply": "setPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->OneVsRest \n\nsetPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[OneVsRest]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[PCA]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setInputCol", "detail": "->PCA", "apply": "setInputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->PCA \n\nsetInputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[PCA]</p>\n<p>Param for input column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setK", "detail": "->PCA", "apply": "setK(${\"value: number\"})", "info": "\n<pre>(['value: number'])->PCA \n\nsetK(%d)\n</pre>\n<hr class=\"solid\">\n<p>[PCA]</p>\n<p>The number of principal components.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setOutputCol", "detail": "->PCA", "apply": "setOutputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->PCA \n\nsetOutputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[PCA]</p>\n<p>Param for output column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[ProbabilisticClassifier]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->ProbabilisticClassifier", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->ProbabilisticClassifier \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[ProbabilisticClassifier]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLabelCol", "detail": "->ProbabilisticClassifier", "apply": "setLabelCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->ProbabilisticClassifier \n\nsetLabelCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[ProbabilisticClassifier]</p>\n<p>Param for label column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->ProbabilisticClassifier", "apply": "setPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->ProbabilisticClassifier \n\nsetPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[ProbabilisticClassifier]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setProbabilityCol", "detail": "->ProbabilisticClassifier", "apply": "setProbabilityCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->ProbabilisticClassifier \n\nsetProbabilityCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[ProbabilisticClassifier]</p>\n<p>Param for Column name for predicted class conditional probabilities.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setRawPredictionCol", "detail": "->ProbabilisticClassifier", "apply": "setRawPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->ProbabilisticClassifier \n\nsetRawPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[ProbabilisticClassifier]</p>\n<p>Param for raw prediction (a.k.a. confidence) column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setThresholds", "detail": "->ProbabilisticClassifier", "apply": "setThresholds(${\"value: [number](Array)\"})", "info": "\n<pre>(['value: [number]'])->ProbabilisticClassifier \n\nsetThresholds(%@f)\n</pre>\n<hr class=\"solid\">\n<p>[ProbabilisticClassifier]</p>\n<p>Param for Thresholds in multi-class classification to adjust the probability of predicting each class.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[QuantileDiscretizer]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setHandleInvalid", "detail": "->QuantileDiscretizer", "apply": "setHandleInvalid(${\"value: string\"})", "info": "\n<pre>(['value: string'])->QuantileDiscretizer \n\nsetHandleInvalid(%s)\n</pre>\n<hr class=\"solid\">\n<p>[QuantileDiscretizer]</p>\n<p>Param for how to handle invalid entries. (Spark 2.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setInputCol", "detail": "->QuantileDiscretizer", "apply": "setInputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->QuantileDiscretizer \n\nsetInputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[QuantileDiscretizer]</p>\n<p>Param for input column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setNumBuckets", "detail": "->QuantileDiscretizer", "apply": "setNumBuckets(${\"value: number\"})", "info": "\n<pre>(['value: number'])->QuantileDiscretizer \n\nsetNumBuckets(%d)\n</pre>\n<hr class=\"solid\">\n<p>[QuantileDiscretizer]</p>\n<p>Number of buckets (quantiles, or categories) into which data points are grouped.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setOutputCol", "detail": "->QuantileDiscretizer", "apply": "setOutputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->QuantileDiscretizer \n\nsetOutputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[QuantileDiscretizer]</p>\n<p>Param for output column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setRelativeError", "detail": "->QuantileDiscretizer", "apply": "setRelativeError(${\"value: number\"})", "info": "\n<pre>(['value: number'])->QuantileDiscretizer \n\nsetRelativeError(%f)\n</pre>\n<hr class=\"solid\">\n<p>[QuantileDiscretizer]</p>\n<p>The relative target precision to achieve (greater or equal to 0). (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[Bucketizer]</p>\n<p>Maps a column of continuous features to a column of feature buckets.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setHandleInvalid", "detail": "->Bucketizer", "apply": "setHandleInvalid(${\"value: string\"})", "info": "\n<pre>(['value: string'])->Bucketizer \n\nsetHandleInvalid(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Bucketizer]</p>\n<p>Param for how to handle invalid entries. (Spark 2.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setInputCol", "detail": "->Bucketizer", "apply": "setInputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->Bucketizer \n\nsetInputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Bucketizer]</p>\n<p>Param for input column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSplits", "detail": "->Bucketizer", "apply": "setSplits(${\"value: [number](Array)\"})", "info": "\n<pre>(['value: [number]'])->Bucketizer \n\nsetSplits(%@f)\n</pre>\n<hr class=\"solid\">\n<p>[Bucketizer]</p>\n<p>Parameter for mapping continuous features into buckets. With n+1 splits, there are n buckets. A bucket defined by splits x,y holds values in the range [x,y) except the last bucket, which also includes y. Splits should be of length greater than or equal to 3 and strictly increasing. Values at -inf, inf must be explicitly provided to cover all Double values; otherwise, values outside the splits specified will be treated as errors.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setOutputCol", "detail": "->Bucketizer", "apply": "setOutputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->Bucketizer \n\nsetOutputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Bucketizer]</p>\n<p>Param for output column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestClassifier]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setCacheNodeIds", "detail": "->RandomForestClassifier", "apply": "setCacheNodeIds(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->RandomForestClassifier \n\nsetCacheNodeIds(%b)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestClassifier]</p>\n<p>If false, the algorithm will pass trees to executors to match instances with nodes.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setCheckpointInterval", "detail": "->RandomForestClassifier", "apply": "setCheckpointInterval(${\"value: number\"})", "info": "\n<pre>(['value: number'])->RandomForestClassifier \n\nsetCheckpointInterval(%d)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestClassifier]</p>\n<p>Param for set checkpoint interval (>= 1) or disable checkpoint (-1).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeatureSubsetStrategy", "detail": "->RandomForestClassifier", "apply": "setFeatureSubsetStrategy(${\"value: string\"})", "info": "\n<pre>(['value: string'])->RandomForestClassifier \n\nsetFeatureSubsetStrategy(%s)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestClassifier]</p>\n<p>The number of features to consider for splits at each tree node.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->RandomForestClassifier", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->RandomForestClassifier \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestClassifier]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setImpurity", "detail": "->RandomForestClassifier", "apply": "setImpurity(${\"value: string\"})", "info": "\n<pre>(['value: string'])->RandomForestClassifier \n\nsetImpurity(%s)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestClassifier]</p>\n<p>Criterion used for information gain calculation (case-insensitive).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLabelCol", "detail": "->RandomForestClassifier", "apply": "setLabelCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->RandomForestClassifier \n\nsetLabelCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestClassifier]</p>\n<p>Param for label column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxBins", "detail": "->RandomForestClassifier", "apply": "setMaxBins(${\"value: number\"})", "info": "\n<pre>(['value: number'])->RandomForestClassifier \n\nsetMaxBins(%d)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestClassifier]</p>\n<p>Maximum number of bins used for discretizing continuous features and for choosing how to split on features at each node.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxDepth", "detail": "->RandomForestClassifier", "apply": "setMaxDepth(${\"value: number\"})", "info": "\n<pre>(['value: number'])->RandomForestClassifier \n\nsetMaxDepth(%d)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestClassifier]</p>\n<p>Maximum depth of the tree (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxMemoryInMB", "detail": "->RandomForestClassifier", "apply": "setMaxMemoryInMB(${\"value: number\"})", "info": "\n<pre>(['value: number'])->RandomForestClassifier \n\nsetMaxMemoryInMB(%d)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestClassifier]</p>\n<p>Maximum memory in MB allocated to histogram aggregation.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMinInfoGain", "detail": "->RandomForestClassifier", "apply": "setMinInfoGain(${\"value: number\"})", "info": "\n<pre>(['value: number'])->RandomForestClassifier \n\nsetMinInfoGain(%f)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestClassifier]</p>\n<p>Minimum information gain for a split to be considered at a tree node.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMinInstancesPerNode", "detail": "->RandomForestClassifier", "apply": "setMinInstancesPerNode(${\"value: number\"})", "info": "\n<pre>(['value: number'])->RandomForestClassifier \n\nsetMinInstancesPerNode(%d)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestClassifier]</p>\n<p>Minimum number of instances each child must have after split.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setNumTrees", "detail": "->RandomForestClassifier", "apply": "setNumTrees(${\"value: number\"})", "info": "\n<pre>(['value: number'])->RandomForestClassifier \n\nsetNumTrees(%d)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestClassifier]</p>\n<p>Number of trees to train (>= 1).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->RandomForestClassifier", "apply": "setPredicitionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->RandomForestClassifier \n\nsetPredicitionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestClassifier]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setProbabilityCol", "detail": "->RandomForestClassifier", "apply": "setProbabilityCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->RandomForestClassifier \n\nsetProbabilityCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestClassifier]</p>\n<p>Param for Column name for predicted class conditional probabilities.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setRawPredictionCol", "detail": "->RandomForestClassifier", "apply": "setRawPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->RandomForestClassifier \n\nsetRawPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestClassifier]</p>\n<p>Param for raw prediction (a.k.a. confidence) column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSeed", "detail": "->RandomForestClassifier", "apply": "setSeed(${\"value: number\"})", "info": "\n<pre>(['value: number'])->RandomForestClassifier \n\nsetSeed(%d)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestClassifier]</p>\n<p>Param for random seed.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSubsamplingRate", "detail": "->RandomForestClassifier", "apply": "setSubsamplingRate(${\"value: number\"})", "info": "\n<pre>(['value: number'])->RandomForestClassifier \n\nsetSubsamplingRate(%f)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestClassifier]</p>\n<p>Fraction of the training data used for learning each decision tree, in range (0, 1].</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setThresholds", "detail": "->RandomForestClassifier", "apply": "setThresholds(${\"value: [number](Array)\"})", "info": "\n<pre>(['value: [number]'])->RandomForestClassifier \n\nsetThresholds(%@f)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestClassifier]</p>\n<p>Param for Thresholds in multi-class classification to adjust the probability of predicting each class.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestRegressor]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setCacheNodeIds", "detail": "->RandomForestRegressor", "apply": "setCacheNodeIds(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->RandomForestRegressor \n\nsetCacheNodeIds(%b)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestRegressor]</p>\n<p>If false, the algorithm will pass trees to executors to match instances with nodes.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setCheckpointInterval", "detail": "->RandomForestRegressor", "apply": "setCheckpointInterval(${\"value: number\"})", "info": "\n<pre>(['value: number'])->RandomForestRegressor \n\nsetCheckpointInterval(%d)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestRegressor]</p>\n<p>Param for set checkpoint interval (>= 1) or disable checkpoint (-1).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeatureSubsetStrategy", "detail": "->RandomForestRegressor", "apply": "setFeatureSubsetStrategy(${\"value: string\"})", "info": "\n<pre>(['value: string'])->RandomForestRegressor \n\nsetFeatureSubsetStrategy(%s)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestRegressor]</p>\n<p>The number of features to consider for splits at each tree node.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->RandomForestRegressor", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->RandomForestRegressor \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestRegressor]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setImpurity", "detail": "->RandomForestRegressor", "apply": "setImpurity(${\"value: string\"})", "info": "\n<pre>(['value: string'])->RandomForestRegressor \n\nsetImpurity(%s)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestRegressor]</p>\n<p>Criterion used for information gain calculation (case-insensitive).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLabelCol", "detail": "->RandomForestRegressor", "apply": "setLabelCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->RandomForestRegressor \n\nsetLabelCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestRegressor]</p>\n<p>Param for label column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxBins", "detail": "->RandomForestRegressor", "apply": "setMaxBins(${\"value: number\"})", "info": "\n<pre>(['value: number'])->RandomForestRegressor \n\nsetMaxBins(%d)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestRegressor]</p>\n<p>Maximum number of bins used for discretizing continuous features and for choosing how to split on features at each node.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxDepth", "detail": "->RandomForestRegressor", "apply": "setMaxDepth(${\"value: number\"})", "info": "\n<pre>(['value: number'])->RandomForestRegressor \n\nsetMaxDepth(%d)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestRegressor]</p>\n<p>Maximum depth of the tree (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxMemoryInMB", "detail": "->RandomForestRegressor", "apply": "setMaxMemoryInMB(${\"value: number\"})", "info": "\n<pre>(['value: number'])->RandomForestRegressor \n\nsetMaxMemoryInMB(%d)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestRegressor]</p>\n<p>Maximum memory in MB allocated to histogram aggregation.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMinInfoGain", "detail": "->RandomForestRegressor", "apply": "setMinInfoGain(${\"value: number\"})", "info": "\n<pre>(['value: number'])->RandomForestRegressor \n\nsetMinInfoGain(%f)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestRegressor]</p>\n<p>Minimum information gain for a split to be considered at a tree node.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMinInstancesPerNode", "detail": "->RandomForestRegressor", "apply": "setMinInstancesPerNode(${\"value: number\"})", "info": "\n<pre>(['value: number'])->RandomForestRegressor \n\nsetMinInstancesPerNode(%d)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestRegressor]</p>\n<p>Minimum number of instances each child must have after split.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setNumTrees", "detail": "->RandomForestRegressor", "apply": "setNumTrees(${\"value: number\"})", "info": "\n<pre>(['value: number'])->RandomForestRegressor \n\nsetNumTrees(%d)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestRegressor]</p>\n<p>Number of trees to train (>= 1).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPredictionCol", "detail": "->RandomForestRegressor", "apply": "setPredictionCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->RandomForestRegressor \n\nsetPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestRegressor]</p>\n<p>Param for prediction column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSeed", "detail": "->RandomForestRegressor", "apply": "setSeed(${\"value: number\"})", "info": "\n<pre>(['value: number'])->RandomForestRegressor \n\nsetSeed(%d)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestRegressor]</p>\n<p>Param for random seed.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSubsamplingRate", "detail": "->RandomForestRegressor", "apply": "setSubsamplingRate(${\"value: number\"})", "info": "\n<pre>(['value: number'])->RandomForestRegressor \n\nsetSubsamplingRate(%f)\n</pre>\n<hr class=\"solid\">\n<p>[RandomForestRegressor]</p>\n<p>Fraction of the training data used for learning each decision tree, in range (0, 1].</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "transform", "info": "\n<pre>([''])->DataFrame \n\ntransform\n</pre>\n<hr class=\"solid\">\n<p>[RegexTokenizer]</p>\n<p>Transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setGaps", "detail": "->RegexTokenizer", "apply": "setGaps(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->RegexTokenizer \n\nsetGaps(%b)\n</pre>\n<hr class=\"solid\">\n<p>[RegexTokenizer]</p>\n<p>Indicates whether regex splits on gaps (true) or matches tokens (false).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setInputCol", "detail": "->RegexTokenizer", "apply": "setInputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->RegexTokenizer \n\nsetInputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[RegexTokenizer]</p>\n<p>Param for input column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMinTokenLength", "detail": "->RegexTokenizer", "apply": "setMinTokenLength(${\"value: number\"})", "info": "\n<pre>(['value: number'])->RegexTokenizer \n\nsetMinTokenLength(%d)\n</pre>\n<hr class=\"solid\">\n<p>[RegexTokenizer]</p>\n<p>Minimum token length, greater than or equal to 0.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setOutputCol", "detail": "->RegexTokenizer", "apply": "setOutputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->RegexTokenizer \n\nsetOutputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[RegexTokenizer]</p>\n<p>Param for output column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setPattern", "detail": "->RegexTokenizer", "apply": "setPattern(${\"value: string\"})", "info": "\n<pre>(['value: string'])->RegexTokenizer \n\nsetPattern(%s)\n</pre>\n<hr class=\"solid\">\n<p>[RegexTokenizer]</p>\n<p>Regex pattern used to match delimiters if gaps is true or tokens if gaps is false.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setToLowercase", "detail": "->RegexTokenizer", "apply": "setToLowercase(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->RegexTokenizer \n\nsetToLowercase(%b)\n</pre>\n<hr class=\"solid\">\n<p>[RegexTokenizer]</p>\n<p>Indicates whether to convert all characters to lowercase before tokenizing. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[RFormula]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFeaturesCol", "detail": "->RFormula", "apply": "setFeaturesCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->RFormula \n\nsetFeaturesCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[RFormula]</p>\n<p>Param for features column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setForceIndexLabel", "detail": "->RFormula", "apply": "setForceIndexLabel(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->RFormula \n\nsetForceIndexLabel(%b)\n</pre>\n<hr class=\"solid\">\n<p>[RFormula]</p>\n<p>Force to index label whether it is numeric or string type. (Spark 2.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setFormula", "detail": "->RFormula", "apply": "setFormula(${\"value: string\"})", "info": "\n<pre>(['value: string'])->RFormula \n\nsetFormula(%s)\n</pre>\n<hr class=\"solid\">\n<p>[RFormula]</p>\n<p>Sets the formula to use for this transformer. Must be called before use.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setLabelCol", "detail": "->RFormula", "apply": "setLabelCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->RFormula \n\nsetLabelCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[RFormula]</p>\n<p>Param for label column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[StandardScaler]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setInputCol", "detail": "->StandardScaler", "apply": "setInputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->StandardScaler \n\nsetInputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[StandardScaler]</p>\n<p>Param for input column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setOutputCol", "detail": "->StandardScaler", "apply": "setOutputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->StandardScaler \n\nsetOutputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[StandardScaler]</p>\n<p>Param for output column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setWithMean", "detail": "->StandardScaler", "apply": "setWithMean(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->StandardScaler \n\nsetWithMean(%b)\n</pre>\n<hr class=\"solid\">\n<p>[StandardScaler]</p>\n<p>Whether to center the data with mean before scaling.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setWithStd", "detail": "->StandardScaler", "apply": "setWithStd(${\"value: boolean\"})", "info": "\n<pre>(['value: boolean'])->StandardScaler \n\nsetWithStd(%b)\n</pre>\n<hr class=\"solid\">\n<p>[StandardScaler]</p>\n<p>Whether to scale the data to unit standard deviation.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[StringIndexer]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setHandleInvalid", "detail": "->StringIndexer", "apply": "setHandleInvalid(${\"value: string\"})", "info": "\n<pre>(['value: string'])->StringIndexer \n\nsetHandleInvalid(%s)\n</pre>\n<hr class=\"solid\">\n<p>[StringIndexer]</p>\n<p>Param for how to handle invalid entries. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setInputCol", "detail": "->StringIndexer", "apply": "setInputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->StringIndexer \n\nsetInputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[StringIndexer]</p>\n<p>Param for input column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setOutputCol", "detail": "->StringIndexer", "apply": "setOutputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->StringIndexer \n\nsetOutputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[StringIndexer]</p>\n<p>Param for output column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[VectorIndexer]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setInputCol", "detail": "->VectorIndexer", "apply": "setInputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->VectorIndexer \n\nsetInputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[VectorIndexer]</p>\n<p>Param for input column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxCategories", "detail": "->VectorIndexer", "apply": "setMaxCategories(${\"value: number\"})", "info": "\n<pre>(['value: number'])->VectorIndexer \n\nsetMaxCategories(%d)\n</pre>\n<hr class=\"solid\">\n<p>[VectorIndexer]</p>\n<p>Threshold for the number of values a categorical feature can take.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setOutputCol", "detail": "->VectorIndexer", "apply": "setOutputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->VectorIndexer \n\nsetOutputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[VectorIndexer]</p>\n<p>Param for output column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "orderBy", "detail": "->WindowSpec", "apply": "orderBy(${\"cols_varargs: Column(Vararg)\"})", "info": "\n<pre>(['cols_varargs: Column'])->WindowSpec \n\norderBy(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[WindowSpec]</p>\n<p>Defines the ordering columns in a WindowSpec.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "partitionBy", "detail": "->WindowSpec", "apply": "partitionBy(${\"cols_varargs: Column(Vararg)\"})", "info": "\n<pre>(['cols_varargs: Column'])->WindowSpec \n\npartitionBy(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[WindowSpec]</p>\n<p>Defines the partitioning columns in a WindowSpec.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "rangeBetween", "detail": "->WindowSpec", "apply": "rangeBetween(${\"start: number\"}, ${\"end: number\"})", "info": "\n<pre>(['start: number', ' end: number'])->WindowSpec \n\nrangeBetween(%d, %d)\n</pre>\n<hr class=\"solid\">\n<p>[WindowSpec]</p>\n<p>Defines the frame boundaries, from start (inclusive) to end (inclusive).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "rowsBetween", "detail": "->WindowSpec", "apply": "rowsBetween(${\"start: number\"}, ${\"end: number\"})", "info": "\n<pre>(['start: number', ' end: number'])->WindowSpec \n\nrowsBetween(%d, %d)\n</pre>\n<hr class=\"solid\">\n<p>[WindowSpec]</p>\n<p>Defines the frame boundaries, from start (inclusive) to end (inclusive).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "run", "detail": "->DataFrame", "apply": "fit(${\"dataset: DataFrame\"}).transform", "info": "\n<pre>(['dataset: DataFrame'])->DataFrame \n\nfit(%r).transform\n</pre>\n<hr class=\"solid\">\n<p>[Word2Vec]</p>\n<p>Fits a model to the input data then transforms this dataset.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setInputCol", "detail": "->Word2Vec", "apply": "setInputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->Word2Vec \n\nsetInputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Word2Vec]</p>\n<p>Param for input column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxIter", "detail": "->Word2Vec", "apply": "setMaxIter(${\"value: number\"})", "info": "\n<pre>(['value: number'])->Word2Vec \n\nsetMaxIter(%d)\n</pre>\n<hr class=\"solid\">\n<p>[Word2Vec]</p>\n<p>Param for maximum number of iterations (>= 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMaxSentenceLength", "detail": "->Word2Vec", "apply": "setMaxSentenceLength(${\"value: number\"})", "info": "\n<pre>(['value: number'])->Word2Vec \n\nsetMaxSentenceLength(%d)\n</pre>\n<hr class=\"solid\">\n<p>[Word2Vec]</p>\n<p>Sets the maximum length (in words) of each sentence in the input data. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setMinCount", "detail": "->Word2Vec", "apply": "setMinCount(${\"value: number\"})", "info": "\n<pre>(['value: number'])->Word2Vec \n\nsetMinCount(%d)\n</pre>\n<hr class=\"solid\">\n<p>[Word2Vec]</p>\n<p>The minimum number of times a token must appear to be included in the word2vec model's vocabulary.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setNumPartitions", "detail": "->Word2Vec", "apply": "setNumPartitions(${\"value: number\"})", "info": "\n<pre>(['value: number'])->Word2Vec \n\nsetNumPartitions(%d)\n</pre>\n<hr class=\"solid\">\n<p>[Word2Vec]</p>\n<p>Number of partitions for sentences of words.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setOutputCol", "detail": "->Word2Vec", "apply": "setOutputCol(${\"value: string\"})", "info": "\n<pre>(['value: string'])->Word2Vec \n\nsetOutputCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Word2Vec]</p>\n<p>Param for output column name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setSeed", "detail": "->Word2Vec", "apply": "setSeed(${\"value: number\"})", "info": "\n<pre>(['value: number'])->Word2Vec \n\nsetSeed(%d)\n</pre>\n<hr class=\"solid\">\n<p>[Word2Vec]</p>\n<p>Param for random seed.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setStepSize", "detail": "->Word2Vec", "apply": "setStepSize(${\"value: number\"})", "info": "\n<pre>(['value: number'])->Word2Vec \n\nsetStepSize(%f)\n</pre>\n<hr class=\"solid\">\n<p>[Word2Vec]</p>\n<p>Param for Step size to be used for each iteration of optimization (> 0).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setVectorSize", "detail": "->Word2Vec", "apply": "setVectorSize(${\"value: number\"})", "info": "\n<pre>(['value: number'])->Word2Vec \n\nsetVectorSize(%d)\n</pre>\n<hr class=\"solid\">\n<p>[Word2Vec]</p>\n<p>The dimension of the code that you want to transform from words.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "setWindowSize", "detail": "->Word2Vec", "apply": "setWindowSize(${\"value: number\"})", "info": "\n<pre>(['value: number'])->Word2Vec \n\nsetWindowSize(%d)\n</pre>\n<hr class=\"solid\">\n<p>[Word2Vec]</p>\n<p>The window size.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "approxCountDistinct", "detail": "->Column", "apply": "approxCountDistinct(${\"e: Column\"} ${2:\"opt_rsd: number(Optional)\"})", "info": "\n<pre>(['e: Column', ' opt_rsd: number'])->Column \n\napproxCountDistinct(%c%,?f)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the approximate number of distinct items in a group.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "avg", "detail": "->Column", "apply": "avg(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\navg(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the average of the values in a group.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "collect_list", "detail": "->Column", "apply": "collect_list(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\ncollect_list(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns a list of objects with duplicates. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "collect_set", "detail": "->Column", "apply": "collect_set(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\ncollect_set(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns a set of objects with duplicate elements eliminated. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "corr", "detail": "->Column", "apply": "corr(${\"column1: Column\"}, ${\"column2: Column\"})", "info": "\n<pre>(['column1: Column', ' column2: Column'])->Column \n\ncorr(%c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the Pearson Correlation Coefficient for two columns. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "count", "detail": "->Column", "apply": "count(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\ncount(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the number of items in a group.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "countDistinct", "detail": "->Column", "apply": "countDistinct(${\"expr: Column\"}%,*c)", "info": "\n<pre>(['expr: Column', ' exprs_varargs: Column'])->Column \n\ncountDistinct(%c%,*c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the number of distinct items in a group.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "covar_pop", "detail": "->Column", "apply": "covar_pop(${\"column1: Column\"}, ${\"column2: Column\"})", "info": "\n<pre>(['column1: Column', ' column2: Column'])->Column \n\ncovar_pop(%c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the population covariance for two columns. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "covar_samp", "detail": "->Column", "apply": "covar_samp(${\"column1: Column\"}, ${\"column2: Column\"})", "info": "\n<pre>(['column1: Column', ' column2: Column'])->Column \n\ncovar_samp(%c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the sample covariance for two columns. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "first", "detail": "->Column", "apply": "first(${\"e: Column\"} ${2:\"opt_ignorenulls: boolean(Optional)\"})", "info": "\n<pre>(['e: Column', ' opt_ignorenulls: boolean'])->Column \n\nfirst(%c%,?b)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the first value in a group.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "grouping", "detail": "->Column", "apply": "grouping(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\ngrouping(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: indicates whether a specified column in a GROUP BY list is aggregated or not, returns 1 for aggregated or 0 for not aggregated in the result set. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "grouping_id", "detail": "->Column", "apply": "grouping_id(${\"cols_varargs: Column(Vararg)\"})", "info": "\n<pre>(['cols_varargs: Column'])->Column \n\ngrouping_id(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the level of grouping. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "kurtosis", "detail": "->Column", "apply": "kurtosis(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nkurtosis(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the kurtosis of the values in a group. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "last", "detail": "->Column", "apply": "last(${\"e: Column\"} ${2:\"opt_ignorenulls: boolean(Optional)\"})", "info": "\n<pre>(['e: Column', ' opt_ignorenulls: boolean'])->Column \n\nlast(%c%,?b)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the last value in a group.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "max", "detail": "->Column", "apply": "max(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nmax(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the maximum value of the expression in the group.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "mean", "detail": "->Column", "apply": "mean(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nmean(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the average of the values in a group.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "min", "detail": "->Column", "apply": "min(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nmin(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the minimum value of the expression in a group.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "skewness", "detail": "->Column", "apply": "skewness(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nskewness(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the skewness of the values in a group. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "stddev", "detail": "->Column", "apply": "stddev(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nstddev(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: alias for stddev_samp. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "stddev_pop", "detail": "->Column", "apply": "stddev_pop(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nstddev_pop(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the population standard deviation of the expression in a group. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "stddev_samp", "detail": "->Column", "apply": "stddev_samp(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nstddev_samp(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the sample standard deviation of the expression in a group. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "sum", "detail": "->Column", "apply": "sum(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nsum(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the sum of all values.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "sumDistinct", "detail": "->Column", "apply": "sumDistinct(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nsumDistinct(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the sum of distinct values in the expression.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "var_pop", "detail": "->Column", "apply": "var_pop(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nvar_pop(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the population variance of the values in a group. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "var_samp", "detail": "->Column", "apply": "var_samp(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nvar_samp(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: returns the unbiased variance of the values in a group. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "variance", "detail": "->Column", "apply": "variance(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nvariance(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Aggregate Functions]</p>\n<p>Aggregate function: alias for var_samp.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "col", "detail": "->Column", "apply": "new Column(${\"colName: string\"})", "info": "\n<pre>(['colName: string'])->Column \n\nnew Column(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Collection Functions]</p>\n<p>Gets the column by name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "array_contains", "detail": "->Column", "apply": "array_contains(${\"column: Column\"}, ${\"value: Object\"})", "info": "\n<pre>(['column: Column', ' value: Object'])->Column \n\narray_contains(%c, %o)\n</pre>\n<hr class=\"solid\">\n<p>[Collection Functions]</p>\n<p>Returns true if the array contain the value.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "explode", "detail": "->Column", "apply": "explode(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nexplode(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Collection Functions]</p>\n<p>Creates a new row for each element in the given array or map column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "explode_outer", "detail": "->Column", "apply": "explode_outer(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nexplode_outer(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Collection Functions]</p>\n<p>Creates a new row for each element in the given array or map column. (Spark 2.2)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "from_json", "detail": "->Column", "apply": "from_json(${\"e: Column\"}, ${\"schema: string\"}, Map())", "info": "\n<pre>(['e: Column', ' schema: string'])->Column \n\nfrom_json(%c, %s, Map())\n</pre>\n<hr class=\"solid\">\n<p>[Collection Functions]</p>\n<p>Parses a column containing a JSON string into a StructType with the specified schema. Returns null, in the case of an unparseable string. (Spark 2.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "get_json_object", "detail": "->Column", "apply": "get_json_object(${\"e: Column\"}, ${\"path: string\"})", "info": "\n<pre>(['e: Column', ' path: string'])->Column \n\nget_json_object(%c, %s)\n</pre>\n<hr class=\"solid\">\n<p>[Collection Functions]</p>\n<p>Extracts json object from a json string based on json path specified, and returns json string of the extracted json object.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "json_tuple", "detail": "->Column", "apply": "json_tuple(${\"json: Column\"}%,*s)", "info": "\n<pre>(['json: Column', ' fields_varargs: string'])->Column \n\njson_tuple(%c%,*s)\n</pre>\n<hr class=\"solid\">\n<p>[Collection Functions]</p>\n<p>Creates a new row for a json column according to the given field names.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "posexplode", "detail": "->Column", "apply": "posexplode(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nposexplode(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Collection Functions]</p>\n<p>Creates a new row for each element with position in the given array or map column. (Spark 2.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "posexplode_outer", "detail": "->Column", "apply": "posexplode_outer(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nposexplode_outer(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Collection Functions]</p>\n<p>Creates a new row for each element with position in the given array or map column. (Spark 2.2)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "size", "detail": "->Column", "apply": "size(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nsize(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Collection Functions]</p>\n<p>Returns length of array or map.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "sort_array", "detail": "->Column", "apply": "sort_array(${\"e: Column\"} ${2:\"opt_asc: boolean(Optional)\"})", "info": "\n<pre>(['e: Column', ' opt_asc: boolean'])->Column \n\nsort_array(%c%,?b)\n</pre>\n<hr class=\"solid\">\n<p>[Collection Functions]</p>\n<p>Sorts the input array for the given column in ascending / descending order, according to the natural ordering of the array elements.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "to_json", "detail": "->Column", "apply": "to_json(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nto_json(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Collection Functions]</p>\n<p>Converts a column containing a StructType into a JSON string with the specified schema. (Spark 2.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "add_months", "detail": "->Column", "apply": "add_months(${\"startDate: Column\"}, ${\"numMonths: number\"})", "info": "\n<pre>(['startDate: Column', ' numMonths: number'])->Column \n\nadd_months(%c, %d)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Returns the date that is numMonths after startDate.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "current_date", "detail": "->Column", "apply": "current_date()", "info": "\n<pre>([''])->Column \n\ncurrent_date()\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Returns the current date as a date column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "current_timestamp", "detail": "->Column", "apply": "current_timestamp()", "info": "\n<pre>([''])->Column \n\ncurrent_timestamp()\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Returns the current timestamp as a timestamp column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "date_add", "detail": "->Column", "apply": "date_add(${\"start: Column\"}, ${\"days: number\"})", "info": "\n<pre>(['start: Column', ' days: number'])->Column \n\ndate_add(%c, %d)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Returns the date that is days days after start.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "date_format", "detail": "->Column", "apply": "date_format(${\"dateExpr: Column\"}, ${\"format: string\"})", "info": "\n<pre>(['dateExpr: Column', ' format: string'])->Column \n\ndate_format(%c, %s)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Converts a date/timestamp/string to a value of string in the format specified by the date format given by the second argument.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "date_sub", "detail": "->Column", "apply": "date_sub(${\"start: Column\"}, ${\"days: number\"})", "info": "\n<pre>(['start: Column', ' days: number'])->Column \n\ndate_sub(%c, %d)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Returns the date that is days days before start.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "datediff", "detail": "->Column", "apply": "datediff(${\"end: Column\"}, ${\"start: Column\"})", "info": "\n<pre>(['end: Column', ' start: Column'])->Column \n\ndatediff(%c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Returns the number of days from start to end.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "dayofmonth", "detail": "->Column", "apply": "dayofmonth(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\ndayofmonth(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Extracts the day of the month as an integer from a given date/timestamp/string.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "dayofyear", "detail": "->Column", "apply": "dayofyear(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\ndayofyear(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Extracts the day of the year as an integer from a given date/timestamp/string.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "from_unixtime", "detail": "->Column", "apply": "from_unixtime(${\"ut: Column\"} ${2:\"opt_f: string(Optional)\"})", "info": "\n<pre>(['ut: Column', ' opt_f: string'])->Column \n\nfrom_unixtime(%c%,?s)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Converts the number of seconds from unix epoch (1970-01-01 00:00:00 UTC) to a string representing the timestamp of that moment in the current system time zone in the given format.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "from_utc_timestamp", "detail": "->Column", "apply": "from_utc_timestamp(${\"ts: Column\"}, ${\"tz: string\"})", "info": "\n<pre>(['ts: Column', ' tz: string'])->Column \n\nfrom_utc_timestamp(%c, %s)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Assumes given timestamp is UTC and converts to given timezone.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "hour", "detail": "->Column", "apply": "hour(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nhour(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Extracts the hours as an integer from a given date/timestamp/string.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "last_day", "detail": "->Column", "apply": "last_day(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nlast_day(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Given a date column, returns the last day of the month which the given date belongs to.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "minute", "detail": "->Column", "apply": "minute(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nminute(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Extracts the minutes as an integer from a given date/timestamp/string.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "month", "detail": "->Column", "apply": "month(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nmonth(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Extracts the month as an integer from a given date/timestamp/string.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "months_between", "detail": "->Column", "apply": "months_between(${\"date1: Column\"}, ${\"date2: Column\"})", "info": "\n<pre>(['date1: Column', ' date2: Column'])->Column \n\nmonths_between(%c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Number of months between date1 and date2.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "next_day", "detail": "->Column", "apply": "next_day(${\"e: Column\"}, ${\"dayOfWeek: string\"})", "info": "\n<pre>(['e: Column', ' dayOfWeek: string'])->Column \n\nnext_day(%c, %s)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Given a date column, returns the first date which is later than the value of the date column that is on the specified day of the week.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "quarter", "detail": "->Column", "apply": "quarter(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nquarter(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Extracts the quarter as an integer from a given date/timestamp/string.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "second", "detail": "->Column", "apply": "second(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nsecond(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Extracts the seconds as an integer from a given date/timestamp/string.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "to_date", "detail": "->Column", "apply": "to_date(${\"e: Column\"} ${2:\"opt_fmt: string(Optional)\"})", "info": "\n<pre>(['e: Column', ' opt_fmt: string'])->Column \n\nto_date(%c%,?s)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Converts the column into DateType. (Spark 2.2)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "to_timestamp", "detail": "->Column", "apply": "to_timestamp(${\"s: Column\"} ${2:\"opt_fmt: string(Optional)\"})", "info": "\n<pre>(['s: Column', ' opt_fmt: string'])->Column \n\nto_timestamp(%c%,?s)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Convert time string to a Unix timestamp (in seconds). (Spark 2.2)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "to_utc_timestamp", "detail": "->Column", "apply": "to_utc_timestamp(${\"ts: Column\"}, ${\"tz: string\"})", "info": "\n<pre>(['ts: Column', ' tz: string'])->Column \n\nto_utc_timestamp(%c, %s)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Assumes given timestamp is in given timezone and converts to UTC.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "trunc", "detail": "->Column", "apply": "trunc(${\"date: Column\"}, ${\"format: string\"})", "info": "\n<pre>(['date: Column', ' format: string'])->Column \n\ntrunc(%c, %s)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Returns date truncated to the unit specified by the format.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "unix_timestamp", "detail": "->Column", "apply": "unix_timestamp(${\"opt_s: Column(Optional)\"} ${2:\"opt_p: string(Optional)\"})", "info": "\n<pre>(['opt_s: Column', ' opt_p: string'])->Column \n\nunix_timestamp(%?c%,?s)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Convert time string with given pattern.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "weekofyear", "detail": "->Column", "apply": "weekofyear(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nweekofyear(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Extracts the week number as an integer from a given date/timestamp/string.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "window", "detail": "->Column", "apply": "window(${\"timeColumn: Column\"}, ${\"windowDuration: string\"} ${3:\"opt_slideDuration: string(Optional)\"} ${4:\"opt_startTime: string(Optional)\"})", "info": "\n<pre>(['timeColumn: Column', ' windowDuration: string', ' opt_slideDuration: string', ' opt_startTime: string'])->Column \n\nwindow(%c, %s%,?s%,?s)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Bucketize rows into one or more time windows given a timestamp specifying column. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "year", "detail": "->Column", "apply": "year(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nyear(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Date Time Functions]</p>\n<p>Extracts the year as an integer from a given date/timestamp/string.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "acos", "detail": "->Column", "apply": "acos(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nacos(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the cosine inverse.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "asin", "detail": "->Column", "apply": "asin(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nasin(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the sine inverse.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "atan", "detail": "->Column", "apply": "atan(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\natan(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the tangent inverse.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "atan2", "detail": "->Column", "apply": "atan2(${\"l: Column\"}, ${\"r: Column\"})", "info": "\n<pre>(['l: Column', ' r: Column'])->Column \n\natan2(%c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Returns the angle theta from the conversion of rectangular coordinates to polar.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "bin", "detail": "->Column", "apply": "bin(e)", "info": "\n<pre>(['e: Column'])->Column \n\nbin(e)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>An expression that returns the string representation of the binary value of the given long column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "bround", "detail": "->Column", "apply": "bround(${\"e: Column\"} ${2:\"opt_scale: number(Optional)\"})", "info": "\n<pre>(['e: Column', ' opt_scale: number'])->Column \n\nbround(%c%,?d)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Round the value of e to scale (defaults to 0) decimal places with HALF_EVEN round mode. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "cbrt", "detail": "->Column", "apply": "cbrt(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\ncbrt(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the cube-root of the given value.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "ceil", "detail": "->Column", "apply": "ceil(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nceil(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the ceiling of the given value.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "clone", "detail": "->Column", "apply": "lit(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nlit(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Creates a copy of a column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "conv", "detail": "->Column", "apply": "conv(${\"num: Column\"}, %n, %n)", "info": "\n<pre>(['num: Column', ' fromBase: number', ' toBase: number'])->Column \n\nconv(%c, %n, %n)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Convert a number in a string column from one base to another.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "cos", "detail": "->Column", "apply": "cos(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\ncos(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the cosine of the given value.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "cosh", "detail": "->Column", "apply": "cosh(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\ncosh(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the hyerbolic cosine of the given value.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "exp", "detail": "->Column", "apply": "exp(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nexp(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the exponential of the given value.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "expm1", "detail": "->Column", "apply": "expm1(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nexpm1(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the exponential of the given value minus one.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "factorial", "detail": "->Column", "apply": "factorial(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nfactorial(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the factorial of the given value.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "floor", "detail": "->Column", "apply": "floor(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nfloor(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the floor of the given value.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "hex", "detail": "->Column", "apply": "hex(${\"column: Column\"})", "info": "\n<pre>(['column: Column'])->Column \n\nhex(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes hex value of the given column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "hypot", "detail": "->Column", "apply": "hypot(${\"l: Column\"}, ${\"r: Column\"})", "info": "\n<pre>(['l: Column', ' r: Column'])->Column \n\nhypot(%c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes sqrt(a^2^ + b^2^) without intermediate overflow or underflow.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "ln", "detail": "->Column", "apply": "log(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nlog(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the natural logarithm of the given value.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "log", "detail": "->Column", "apply": "log(${\"base: number\"}, ${\"a: Column\"})", "info": "\n<pre>(['base: number', ' a: Column'])->Column \n\nlog(%f, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Returns the first argument-base logarithm of the second argument.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "log10", "detail": "->Column", "apply": "log10(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nlog10(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the logarithm of the given value in Base 10.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "log1p", "detail": "->Column", "apply": "log1p(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nlog1p(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the natural logarithm of the given value plus one.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "log2", "detail": "->Column", "apply": "log2(${\"expr: Column\"})", "info": "\n<pre>(['expr: Column'])->Column \n\nlog2(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the logarithm of the given column in base 2.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "pmod", "detail": "->Column", "apply": "pmod(${\"dividend: Column\"}, ${\"divisor: Column\"})", "info": "\n<pre>(['dividend: Column', ' divisor: Column'])->Column \n\npmod(%c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Returns the positive value of dividend mod divisor.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "pow", "detail": "->Column", "apply": "pow(${\"left: Column\"}, ${\"right: Column\"})", "info": "\n<pre>(['left: Column', ' right: Column'])->Column \n\npow(%c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Returns the value of the first argument raised to the power of the second.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "rint", "detail": "->Column", "apply": "rint(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nrint(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Returns the double value that is closest in value to the argument and is equal to a mathematical integer.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "round", "detail": "->Column", "apply": "round(${\"e: Column\"} ${2:\"opt_scale: number(Optional)\"})", "info": "\n<pre>(['e: Column', ' opt_scale: number'])->Column \n\nround(%c%,?d)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Round the value of e to scale decimal places if scale >= 0 or at integral part when scale < 0.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "shiftLeft", "detail": "->Column", "apply": "shiftLeft(${\"e: Column\"}, ${\"numBits: number\"})", "info": "\n<pre>(['e: Column', ' numBits: number'])->Column \n\nshiftLeft(%c, %d)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Shift the the given value numBits left.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "shiftRight", "detail": "->Column", "apply": "shiftRight(${\"e: Column\"}, ${\"numBits: number\"})", "info": "\n<pre>(['e: Column', ' numBits: number'])->Column \n\nshiftRight(%c, %d)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Shift the the given value numBits right.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "shiftRightUnsigned", "detail": "->Column", "apply": "shiftRightUnsigned(${\"e: Column\"}, ${\"numBits: number\"})", "info": "\n<pre>(['e: Column', ' numBits: number'])->Column \n\nshiftRightUnsigned(%c, %d)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Unsigned shift the the given value numBits right.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "signum", "detail": "->Column", "apply": "signum(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nsignum(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the signum of the given value.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "sin", "detail": "->Column", "apply": "sin(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nsin(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the sine of the given value.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "sinh", "detail": "->Column", "apply": "sinh(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nsinh(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the hyperbolic sine of the given value.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "sqrt", "detail": "->Column", "apply": "sqrt(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nsqrt(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the square root of the specified float value.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "tan", "detail": "->Column", "apply": "tan(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\ntan(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the tangent of the given value.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "tanh", "detail": "->Column", "apply": "fn(e: Column) -> Column", "info": "\n<pre>(['e: Column'])->Column \n\nfn(e: Column) -> Column\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Computes the hyperbolic tangent of the given value.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "toDegrees", "detail": "->Column", "apply": "toDegrees(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\ntoDegrees(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Converts an angle measured in radians to an approximately equivalent angle measured in degrees.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "toRadians", "detail": "->Column", "apply": "toRadians(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\ntoRadians(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Converts an angle measured in degrees to an approximately equivalent angle measured in radians.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "unhex", "detail": "->Column", "apply": "unhex(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nunhex(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Math Functions]</p>\n<p>Inverse of hex.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "crc32", "detail": "->Column", "apply": "crc32(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\ncrc32(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Misc Functions]</p>\n<p>Calculates the cyclic redundancy check value (CRC32) of a binary column and returns the value as a bigint.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "hash", "detail": "->Column", "apply": "hash(${\"cols_varargs: Column(Vararg)\"})", "info": "\n<pre>(['cols_varargs: Column'])->Column \n\nhash(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[Misc Functions]</p>\n<p>Calculates the hash code of given columns, and returns the result as an int column. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "md5", "detail": "->Column", "apply": "md5(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nmd5(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Misc Functions]</p>\n<p>Calculates the MD5 digest of a binary column and returns the value as a 32 character hex string.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "sha1", "detail": "->Column", "apply": "sha1(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nsha1(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Misc Functions]</p>\n<p>Calculates the SHA-1 digest of a binary column and returns the value as a 40 character hex string.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "sha2", "detail": "->Column", "apply": "sha2(${\"e: Column\"})", "info": "\n<pre>(['e: Column', ' numBits: number'])->Column \n\nsha2(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Misc Functions]</p>\n<p>Calculates the SHA-2 family of hash functions of a binary column and returns the value as a hex string.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "abs", "detail": "->Column", "apply": "abs(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nabs(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Non Aggregate Functions]</p>\n<p>Computes the absolute value.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "array", "detail": "->Column", "apply": "array(${\"cols_varargs: Column(Vararg)\"})", "info": "\n<pre>(['cols_varargs: Column'])->Column \n\narray(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[Non Aggregate Functions]</p>\n<p>Creates a new array column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "bitwiseNot", "detail": "->Column", "apply": "bitwiseNOT(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nbitwiseNOT(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Non Aggregate Functions]</p>\n<p>Computes bitwise NOT.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "coalesce", "detail": "->Column", "apply": "coalesce(${\"e_varargs: Column(Vararg)\"})", "info": "\n<pre>(['e_varargs: Column'])->Column \n\ncoalesce(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[Non Aggregate Functions]</p>\n<p>Returns the first column that is not null.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "expr", "detail": "->Column", "apply": "expr(${\"expr: string\"})", "info": "\n<pre>(['expr: string'])->Column \n\nexpr(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Non Aggregate Functions]</p>\n<p>Parses the expression string into the column that it represents, similar to DataFrame.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "greatest", "detail": "->Column", "apply": "greatest(${\"exprs_varargs: Column(Vararg)\"})", "info": "\n<pre>(['exprs_varargs: Column'])->Column \n\ngreatest(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[Non Aggregate Functions]</p>\n<p>Returns the greatest value of the list of values, skipping null values.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "input_file_name", "detail": "->Column", "apply": "input_file_name()", "info": "\n<pre>([''])->Column \n\ninput_file_name()\n</pre>\n<hr class=\"solid\">\n<p>[Non Aggregate Functions]</p>\n<p>Creates a string column for the file name of the current Spark task. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "isnan", "detail": "->Column", "apply": "isnan(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nisnan(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Non Aggregate Functions]</p>\n<p>Return true iff the column is NaN. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "isnull", "detail": "->Column", "apply": "isnull(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nisnull(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Non Aggregate Functions]</p>\n<p>Return true iff the column is null.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "least", "detail": "->Column", "apply": "least(${\"exprs_varargs: Column(Vararg)\"})", "info": "\n<pre>(['exprs_varargs: Column'])->Column \n\nleast(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[Non Aggregate Functions]</p>\n<p>Returns the least value of the list of values, skipping null values.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "map", "detail": "->Column", "apply": "map(${\"cols_varargs: Column(Vararg)\"})", "info": "\n<pre>(['cols_varargs: Column'])->Column \n\nmap(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[Non Aggregate Functions]</p>\n<p>Creates a new map column. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "monotonically_increasing_id", "detail": "->Column", "apply": "monotonically_increasing_id()", "info": "\n<pre>([''])->Column \n\nmonotonically_increasing_id()\n</pre>\n<hr class=\"solid\">\n<p>[Non Aggregate Functions]</p>\n<p>Generates monotonically increasing 64-bit integers.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "nanv1", "detail": "->Column", "apply": "nanv1(${\"col1: Column\"}, ${\"col2: Column\"})", "info": "\n<pre>(['col1: Column', ' col2: Column'])->Column \n\nnanv1(%c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Non Aggregate Functions]</p>\n<p>Returns col1 if it is not NaN, or col2 if col1 is NaN.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "negate", "detail": "->Column", "apply": "negate(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nnegate(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Non Aggregate Functions]</p>\n<p>Unary minus.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "not", "detail": "->Column", "apply": "not(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nnot(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Non Aggregate Functions]</p>\n<p>Inversion of boolean expression.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "rand", "detail": "->Column", "apply": "rand(${\"opt_seed: number(Optional)\"})", "info": "\n<pre>(['opt_seed: number'])->Column \n\nrand(%?d)\n</pre>\n<hr class=\"solid\">\n<p>[Non Aggregate Functions]</p>\n<p>Generate a random column with i.i.d. samples from U[0.0, 1.0].</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "randn", "detail": "->Column", "apply": "randn(${\"opt_seed: number(Optional)\"})", "info": "\n<pre>(['opt_seed: number'])->Column \n\nrandn(%?d)\n</pre>\n<hr class=\"solid\">\n<p>[Non Aggregate Functions]</p>\n<p>Generate a column with i.i.d. samples from the standard normal distribution.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "spark_partition_id", "detail": "->Column", "apply": "spark_partition_id()", "info": "\n<pre>([''])->Column \n\nspark_partition_id()\n</pre>\n<hr class=\"solid\">\n<p>[Non Aggregate Functions]</p>\n<p>Partition ID of the Spark task. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "struct", "detail": "->Column", "apply": "struct(${\"cols_varargs: Column(Vararg)\"})", "info": "\n<pre>(['cols_varargs: Column'])->Column \n\nstruct(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[Non Aggregate Functions]</p>\n<p>Creates a new struct column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "when", "detail": "->ConditionChain", "apply": "when(${\"condition: Column\"}, ${\"value: Column\"})", "info": "\n<pre>(['condition: Column', ' value: Column'])->ConditionChain \n\nwhen(%c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Non Aggregate Functions]</p>\n<p>Evaluates a list of conditions and returns one of multiple values.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "asc", "detail": "->Column", "apply": "asc(${\"columnName: string\"})", "info": "\n<pre>(['columnName: string'])->Column \n\nasc(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Sorting Functions]</p>\n<p>Returns a sort expression based on ascending order of the column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "asc_nulls_first", "detail": "->Column", "apply": "asc_nulls_first(${\"columnName: string\"})", "info": "\n<pre>(['columnName: string'])->Column \n\nasc_nulls_first(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Sorting Functions]</p>\n<p>Returns a sort expression based on ascending order of the column, and null values return before non-null values. (Spark 2.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "asc_nulls_last", "detail": "->Column", "apply": "asc_nulls_last(${\"columnName: string\"})", "info": "\n<pre>(['columnName: string'])->Column \n\nasc_nulls_last(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Sorting Functions]</p>\n<p>Returns a sort expression based on ascending order of the column, and null values appear after non-null values. (Spark 2.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "desc", "detail": "->Column", "apply": "desc(${\"columnName: string\"})", "info": "\n<pre>(['columnName: string'])->Column \n\ndesc(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Sorting Functions]</p>\n<p>Returns a sort expression based on descending order of the column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "desc_nulls_first", "detail": "->Column", "apply": "desc_nulls_first(${\"columnName: string\"})", "info": "\n<pre>(['columnName: string'])->Column \n\ndesc_nulls_first(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Sorting Functions]</p>\n<p>Returns a sort expression based on the descending order of the column, and null values appear before non-null values. (Spark 2.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "desc_nulls_last", "detail": "->Column", "apply": "desc_nulls_last(${\"columnName: string\"})", "info": "\n<pre>(['columnName: string'])->Column \n\ndesc_nulls_last(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Sorting Functions]</p>\n<p>Returns a sort expression based on the descending order of the column, and null values appear after non-null values. (Spark 2.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "ascii", "detail": "->Column", "apply": "ascii(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nascii(%c)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Computes the numeric value of the first character of the string column, and returns the result as a int column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "base64", "detail": "->Column", "apply": "base64(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nbase64(%c)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Computes the BASE64 encoding of a binary column and returns it as a string column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "concat", "detail": "->Column", "apply": "concat(${\"exprs_varargs: Column(Vararg)\"})", "info": "\n<pre>(['exprs_varargs: Column'])->Column \n\nconcat(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Concatenates multiple input string columns together into a single string column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "concat_ws", "detail": "->Column", "apply": "concat_ws(${\"sep: string\"}%,*c)", "info": "\n<pre>(['sep: string', ' exprs_varargs: Column'])->Column \n\nconcat_ws(%s%,*c)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Concatenates multiple input string columns together into a single string column, using the given separator.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "decode", "detail": "->Column", "apply": "decode(${\"value: Column\"}, ${\"charset: string\"})", "info": "\n<pre>(['value: Column', ' charset: string'])->Column \n\ndecode(%c, %s)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Computes the first argument into a string from a binary using the provided character set (one of 'US-ASCII', 'ISO-8859-1', 'UTF-8', 'UTF-16BE', 'UTF-16LE', 'UTF-16').</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "encode", "detail": "->Column", "apply": "encode(${\"value: Column\"}, ${\"charset: string\"})", "info": "\n<pre>(['value: Column', ' charset: string'])->Column \n\nencode(%c, %s)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Computes the first argument into a binary from a string using the provided character set (one of 'US-ASCII', 'ISO-8859-1', 'UTF-8', 'UTF-16BE', 'UTF-16LE', 'UTF-16').</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "format_number", "detail": "->Column", "apply": "format_number(${\"x: Column\"}, ${\"d: number\"})", "info": "\n<pre>(['x: Column', ' d: number'])->Column \n\nformat_number(%c, %d)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Formats numeric column x to a format like '#,###,###.##', rounded to d decimal places, and returns the result as a string column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "format_string", "detail": "->Column", "apply": "format_string(${\"format: string\"}%,*c)", "info": "\n<pre>(['format: string', ' arguments_varargs: Column'])->Column \n\nformat_string(%c%,*c)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Formats the arguments in printf-style and returns the result as a string column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "initcap", "detail": "->Column", "apply": "initcap(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\ninitcap(%c)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Returns a new string column by converting the first letter of each word to uppercase.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "instr", "detail": "->Column", "apply": "instr(${\"str: Column\"})", "info": "\n<pre>(['str: Column', ' substring: string'])->Column \n\ninstr(%c)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Locate the position of the first occurrence of substr column in the given string.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "length", "detail": "->Column", "apply": "length(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nlength(%c)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Computes the length of a given string or binary column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "levenshtein", "detail": "->Column", "apply": "levenshtein(${\"l: Column\"})", "info": "\n<pre>(['l: Column', ' r: Column'])->Column \n\nlevenshtein(%c)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Computes the Levenshtein distance of the two given string columns.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "locate", "detail": "->Column", "apply": "locate(${\"substr: string\"}, ${\"str: Column\"} ${3:\"opt_pos: number(Optional)\"})", "info": "\n<pre>(['substr: string', ' str: Column', ' opt_pos: number'])->Column \n\nlocate(%s, %c%,?d)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Locate the position of the first occurrence of substr in a string column, after position pos.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "lower", "detail": "->Column", "apply": "lower(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nlower(%c)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Converts a string column to lower case.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "lpad", "detail": "->Column", "apply": "lpad(${\"str: Column\"}, ${\"len: number\"}, ${\"pad: string\"})", "info": "\n<pre>(['str: Column', ' len: number', ' pad: string'])->Column \n\nlpad(%c, %d, %s)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Left-pad the string column with pad to a length of len.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "ltrim", "detail": "->Column", "apply": "ltrim(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nltrim(%c)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Trim the spaces from left end for the specified string value.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "regexp_extract", "detail": "->Column", "apply": "regexp_extract(${\"e: Column\"}, ${\"exp: string\"}, ${\"groupIdx: number\"})", "info": "\n<pre>(['e: Column', ' exp: string', ' groupIdx: number'])->Column \n\nregexp_extract(%c, %s, %d)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Extract a specific(idx) group identified by a java regex, from the specified string column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "regexp_replace", "detail": "->Column", "apply": "regexp_replace(${\"e: Column\"}, ${\"pattern: string\"}, ${\"replacement: string\"})", "info": "\n<pre>(['e: Column', ' pattern: string', ' replacement: string'])->Column \n\nregexp_replace(%c, %s, %s)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Replace all substrings of the specified string value that match regexp with rep.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "repeat", "detail": "->Column", "apply": "repeat(${\"str: Column\"}, ${\"n: number\"})", "info": "\n<pre>(['str: Column', ' n: number'])->Column \n\nrepeat(%c, %d)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Repeats a string column n times, and returns it as a new string column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "reverse", "detail": "->Column", "apply": "reverse(${\"str: Column\"})", "info": "\n<pre>(['str: Column'])->Column \n\nreverse(%c)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Reverses the string column and returns it as a new string column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "rpad", "detail": "->Column", "apply": "rpad(${\"str: Column\"}, ${\"len: number\"}, ${\"pad: string\"})", "info": "\n<pre>(['str: Column', ' len: number', ' pad: string'])->Column \n\nrpad(%c, %d, %s)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Right-padded with pad to a length of len.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "rtrim", "detail": "->Column", "apply": "rtrim(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nrtrim(%c)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Trim the spaces from right end for the specified string value.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "soundex", "detail": "->Column", "apply": "soundex(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nsoundex(%c)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Return the soundex code for the specified expression.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "split", "detail": "->Column", "apply": "split(${\"str: Column\"}, ${\"pattern: string\"})", "info": "\n<pre>(['str: Column', ' pattern: string'])->Column \n\nsplit(%c, %s)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Splits str around pattern (pattern is a regular expression).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "substring", "detail": "->Column", "apply": "substring(${\"str: Column\"}, ${\"pos: number\"}, ${\"len: number\"})", "info": "\n<pre>(['str: Column', ' pos: number', ' len: number'])->Column \n\nsubstring(%c, %d, %d)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Substring starts at pos and is of length len when str is String type or returns the slice of byte array that starts at pos in byte and is of length len when str is Binary type.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "substring_index", "detail": "->Column", "apply": "substring_index(${\"str: Column\"}, ${\"delim: string\"}, ${\"count: number\"})", "info": "\n<pre>(['str: Column', ' delim: string', ' count: number'])->Column \n\nsubstring_index(%c, %s, %d)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Returns the substring from string str before count occurrences of the delimiter delim.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "translate", "detail": "->Column", "apply": "translate(${\"src: Column\"}, ${\"matchingString: string\"}, ${\"replaceString: string\"})", "info": "\n<pre>(['src: Column', ' matchingString: string', ' replaceString: string'])->Column \n\ntranslate(%c, %s, %s)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Translate any character in the src by a character in replaceString.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "trim", "detail": "->Column", "apply": "trim(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\ntrim(%c)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Trim the spaces from both ends for the specified string column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "unbase64", "detail": "->Column", "apply": "unbase64(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nunbase64(%c)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Decodes a BASE64 encoded string column and returns it as a binary column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "upper", "detail": "->Column", "apply": "upper(${\"e: Column\"})", "info": "\n<pre>(['e: Column'])->Column \n\nupper(%c)\n</pre>\n<hr class=\"solid\">\n<p>[String Functions]</p>\n<p>Converts a string column to upper case.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "cume_dist", "detail": "->Column", "apply": "cume_dist()", "info": "\n<pre>([''])->Column \n\ncume_dist()\n</pre>\n<hr class=\"solid\">\n<p>[Window Functions]</p>\n<p>Window function: returns the cumulative distribution of values within a window partition. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "dense_rank", "detail": "->Column", "apply": "dense_rank()", "info": "\n<pre>([''])->Column \n\ndense_rank()\n</pre>\n<hr class=\"solid\">\n<p>[Window Functions]</p>\n<p>Window function: returns the rank of rows within a window partition, without any gaps. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "lag", "detail": "->Column", "apply": "lag(${\"e: Column\"}, ${\"offset: number\"} ${3:\"opt_defaultValue: Column(Optional)\"})", "info": "\n<pre>(['e: Column', ' offset: number', ' opt_defaultValue: Column'])->Column \n\nlag(%c, %d%,?c)\n</pre>\n<hr class=\"solid\">\n<p>[Window Functions]</p>\n<p>Window function: returns the value that is offset rows before the current row, and defaultValue if there is less than offset rows before the current row.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "lead", "detail": "->Column", "apply": "lead(${\"e: Column\"}, ${\"offset: number\"} ${3:\"opt_defaultValue: Column(Optional)\"})", "info": "\n<pre>(['e: Column', ' offset: number', ' opt_defaultValue: Column'])->Column \n\nlead(%c, %d%,?c)\n</pre>\n<hr class=\"solid\">\n<p>[Window Functions]</p>\n<p>Window function: returns the value that is offset rows after the current row, and defaultValue if there is less than offset rows after the current row.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "ntile", "detail": "->Column", "apply": "ntile(${\"n: number\"})", "info": "\n<pre>(['n: number'])->Column \n\nntile(%d)\n</pre>\n<hr class=\"solid\">\n<p>[Window Functions]</p>\n<p>Window function: returns the ntile group id (from 1 to n inclusive) in an ordered window partition.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "percent_rank", "detail": "->Column", "apply": "percent_rank(%n)", "info": "\n<pre>([''])->Column \n\npercent_rank(%n)\n</pre>\n<hr class=\"solid\">\n<p>[Window Functions]</p>\n<p>Window function: returns the relative rank (i.e. percentile) of rows within a window partition. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "rank", "detail": "->Column", "apply": "rank()", "info": "\n<pre>([''])->Column \n\nrank()\n</pre>\n<hr class=\"solid\">\n<p>[Window Functions]</p>\n<p>Window function: returns the rank of rows within a window partition.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "row_number", "detail": "->Column", "apply": "row_number()", "info": "\n<pre>([''])->Column \n\nrow_number()\n</pre>\n<hr class=\"solid\">\n<p>[Window Functions]</p>\n<p>Window function: returns a sequential number starting at 1 within a window partition. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "add", "detail": "->Column", "apply": "${\"col1: Column\"}.plus(${\"col2: Column\"})", "info": "\n<pre>(['col1: Column', ' col2: Column'])->Column \n\n%c.plus(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Add two numbers together.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "and", "detail": "->Column", "apply": "${\"left: Column\"}.and(${\"right: Column\"})", "info": "\n<pre>(['left: Column', ' right: Column'])->Column \n\n%c.and(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Boolean AND.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "between", "detail": "->Column", "apply": "${\"e: Column\"}.between(${\"lowerBound: Column\"}, ${\"upperBound: Column\"})", "info": "\n<pre>(['e: Column', ' lowerBound: Column', ' upperBound: Column'])->Column \n\n%c.between(%c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>True if column is between the lower bound and upper bound, inclusive</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "bitwiseAnd", "detail": "->Column", "apply": "${\"left: Column\"}.bitwiseAND(${\"right: Column\"})", "info": "\n<pre>(['left: Column', ' right: Column'])->Column \n\n%c.bitwiseAND(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Compute bitwise AND of two expressions.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "bitwiseOr", "detail": "->Column", "apply": "${\"left: Column\"}.bitwiseOR(${\"right: Column\"})", "info": "\n<pre>(['left: Column', ' right: Column'])->Column \n\n%c.bitwiseOR(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Compute bitwise OR of two expressions.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "bitwiseXor", "detail": "->Column", "apply": "${\"left: Column\"}.bitwiseXOR(${\"right: Column\"})", "info": "\n<pre>(['left: Column', ' right: Column'])->Column \n\n%c.bitwiseXOR(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Compute bitwise XOR of two expressions.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "contains", "detail": "->Column", "apply": "${\"e: Column\"}.contains(${\"other: Column\"})", "info": "\n<pre>(['e: Column', ' other: Column'])->Column \n\n%c.contains(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Contains the other column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "divide", "detail": "->Column", "apply": "${\"col1: Column\"}.divide(${\"col2: Column\"})", "info": "\n<pre>(['col1: Column', ' col2: Column'])->Column \n\n%c.divide(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Divides one number by another.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "endsWith", "detail": "->Column", "apply": "${\"e: Column\"}.endsWith(${\"other: Column\"})", "info": "\n<pre>(['e: Column', ' other: Column'])->Column \n\n%c.endsWith(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>String ends with.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "equal", "detail": "->Column", "apply": "${\"left: Column\"}.equalTo(${\"right: Column\"})", "info": "\n<pre>(['left: Column', ' right: Column'])->Column \n\n%c.equalTo(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Equality test.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "equalNullSafe", "detail": "->Column", "apply": "${\"left: Column\"}.eqNullSafe(${\"right: Column\"})", "info": "\n<pre>(['left: Column', ' right: Column'])->Column \n\n%c.eqNullSafe(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Equality test that is safe for null values.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "getField", "detail": "->Column", "apply": "${\"e: Column\"}.getField(${\"fieldName: string\"})", "info": "\n<pre>(['e: Column', ' fieldName: string'])->Column \n\n%c.getField(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Gets a field by name in a struct.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "getItem", "detail": "->Column", "apply": "${\"e: Column\"}.getItem(${\"key: Object\"})", "info": "\n<pre>(['e: Column', ' key: Object'])->Column \n\n%c.getItem(%o)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Gets at item out of an array or a map.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "greaterThan", "detail": "->Column", "apply": "${\"left: Column\"}.gt(${\"right: Column\"})", "info": "\n<pre>(['left: Column', ' right: Column'])->Column \n\n%c.gt(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Greater than.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "greaterThanOrEqual", "detail": "->Column", "apply": "${\"left: Column\"}.geq(${\"right: Column\"})", "info": "\n<pre>(['left: Column', ' right: Column'])->Column \n\n%c.geq(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Greater than or equal to.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "isin", "detail": "->Column", "apply": "${\"value: Column\"}.isin(${\"list_varargs: Column(Vararg)\"})", "info": "\n<pre>(['value: Column', ' list_varargs: Column'])->Column \n\n%c.isin(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Determines if the value is contained in the list.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "isNotNull", "detail": "->Column", "apply": "${\"e: Column\"}.isNotNull", "info": "\n<pre>(['e: Column'])->Column \n\n%c.isNotNull\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>True if the column is NOT null.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "lessThan", "detail": "->Column", "apply": "${\"left: Column\"}.lt(${\"right: Column\"})", "info": "\n<pre>(['left: Column', ' right: Column'])->Column \n\n%c.lt(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Less than.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "lessThanOrEqual", "detail": "->Column", "apply": "${\"left: Column\"}.leq(${\"right: Column\"})", "info": "\n<pre>(['left: Column', ' right: Column'])->Column \n\n%c.leq(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Less than or equal to.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "like", "detail": "->Column", "apply": "${\"e: Column\"}.like(${\"literal: string\"})", "info": "\n<pre>(['e: Column', ' literal: string'])->Column \n\n%c.like(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>SQL like expression.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "mod", "detail": "->Column", "apply": "${\"left: Column\"}.mod(${\"right: Column\"})", "info": "\n<pre>(['left: Column', ' right: Column'])->Column \n\n%c.mod(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Remainder.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "multiply", "detail": "->Column", "apply": "${\"col1: Column\"}.multiply(${\"col2: Column\"})", "info": "\n<pre>(['col1: Column', ' col2: Column'])->Column \n\n%c.multiply(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Multiplies one column by another.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "notEqual", "detail": "->Column", "apply": "${\"left: Column\"}.notEqual(${\"right: Column\"})", "info": "\n<pre>(['left: Column', ' right: Column'])->Column \n\n%c.notEqual(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Inequality test.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "or", "detail": "->Column", "apply": "${\"left: Column\"}.or(${\"right: Column\"})", "info": "\n<pre>(['left: Column', ' right: Column'])->Column \n\n%c.or(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Boolean OR.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "rlike", "detail": "->Column", "apply": "${\"e: Column\"}.rlike(${\"literal: string\"})", "info": "\n<pre>(['e: Column', ' literal: string'])->Column \n\n%c.rlike(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>LIKE with Regex.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "startsWith", "detail": "->Column", "apply": "${\"e: Column\"}.startsWith(${\"other: Column\"})", "info": "\n<pre>(['e: Column', ' other: Column'])->Column \n\n%c.startsWith(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>String starts with.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "substr", "detail": "->Column", "apply": "${\"e: Column\"}.substr(${\"startPos: Column\"}, ${\"len: Column\"})", "info": "\n<pre>(['e: Column', ' startPos: Column', ' len: Column'])->Column \n\n%c.substr(%c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>An expression that returns a substring.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "subtract", "detail": "->Column", "apply": "${\"col1: Column\"}.minus(${\"col2: Column\"})", "info": "\n<pre>(['col1: Column', ' col2: Column'])->Column \n\n%c.minus(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Column Expression Operators]</p>\n<p>Subtracts one number from another.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "agg", "detail": "->DataFrame", "apply": "agg(${\"expr: Column\"}%,*c)", "info": "\n<pre>(['expr: Column', ' exprs_varargs: Column'])->DataFrame \n\nagg(%c%,*c)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Aggregates on the entire DataFrame without groups.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "crossJoin", "detail": "->DataFrame", "apply": "crossJoin(${\"right: DataFrame\"})", "info": "\n<pre>(['right: DataFrame'])->DataFrame \n\ncrossJoin(%r)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Explicit cartesian join with another DataFrame. (Spark 2.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "cube", "detail": "->GroupedData", "apply": "cube(${\"cols_varargs: Column(Vararg)\"})", "info": "\n<pre>(['cols_varargs: Column'])->GroupedData \n\ncube(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Create a multi-dimensional cube for the current DataFrame using the specified columns, so we can run aggregation on them.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "describe", "detail": "->DataFrame", "apply": "describe(${\"cols_varargs: string(Vararg)\"})", "info": "\n<pre>(['cols_varargs: string'])->DataFrame \n\ndescribe(%*s)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Computes statistics for numeric and string columns, including count, mean, stddev, min, and max. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "drop", "detail": "->DataFrame", "apply": "drop(${\"colName: string\"})", "info": "\n<pre>(['colName: string'])->DataFrame \n\ndrop(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Drops the specified column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "dropDuplicates", "detail": "->DataFrame", "apply": "dropDuplicates(${\"cols_varargs: string(Vararg)\"})", "info": "\n<pre>(['cols_varargs: string'])->DataFrame \n\ndropDuplicates(%*s)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Returns a new Dataset with duplicate rows removed, considering only the subset of columns.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "except", "detail": "->DataFrame", "apply": "except(${\"other: DataFrame\"})", "info": "\n<pre>(['other: DataFrame'])->DataFrame \n\nexcept(%r)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Returns a new Dataset containing rows in this Dataset but not in another Dataset. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "filter", "detail": "->DataFrame", "apply": "filter(${\"condition: Column\"})", "info": "\n<pre>(['condition: Column'])->DataFrame \n\nfilter(%c)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Filters rows using the given condition.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "groupBy", "detail": "->GroupedData", "apply": "groupBy(${\"col1: Column(Vararg)\"})", "info": "\n<pre>(['col1: Column', ' cols_varargs: Column'])->GroupedData \n\ngroupBy(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Groups using the specified columns.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "intersect", "detail": "->DataFrame", "apply": "intersect(${\"other: DataFrame\"})", "info": "\n<pre>(['other: DataFrame'])->DataFrame \n\nintersect(%r)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Returns a new Dataset containing rows only in both this Dataset and another Dataset. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "join", "detail": "->DataFrame", "apply": "join(${\"right: DataFrame\"}, ${\"joinExprs: Column\"} ${3:\"opt_joinType: string(Optional)\"})", "info": "\n<pre>(['right: DataFrame', ' joinExprs: Column', ' opt_joinType: string'])->DataFrame \n\njoin(%r, %c%,?s)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Join with another DataFrame, using the given join expression.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "limit", "detail": "->DataFrame", "apply": "limit(${\"n: number\"})", "info": "\n<pre>(['n: number'])->DataFrame \n\nlimit(%d)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Returns a new DataFrame by taking the first n rows.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "repartition", "detail": "->DataFrame", "apply": "repartition(${\"partitionExprs_varargs: Column(Vararg)\"})", "info": "\n<pre>(['partitionExprs_varargs: Column'])->DataFrame \n\nrepartition(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Returns a new DataFrame partitioned by the given partitioning expressions preserving the existing number of partitions. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "rollup", "detail": "->GroupedData", "apply": "rollup(${\"cols_varargs: Column(Vararg)\"})", "info": "\n<pre>(['cols_varargs: Column'])->GroupedData \n\nrollup(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Create a multi-dimensional rollup for the current DataFrame using the specified columns, so we can run aggregation on them.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "sample", "detail": "->DataFrame", "apply": "sample(${\"withReplacement: boolean\"}, ${\"fraction: number\"} ${3:\"opt_seed: number(Optional)\"})", "info": "\n<pre>(['withReplacement: boolean', ' fraction: number', ' opt_seed: number'])->DataFrame \n\nsample(%b, %f%,?d)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Returns a new DataFrame by sampling a fraction of rows.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "select", "detail": "->DataFrame", "apply": "select(${\"cols_varargs: Column(Vararg)\"})", "info": "\n<pre>(['cols_varargs: Column'])->DataFrame \n\nselect(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Selects a set of column based expressions.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "sort", "detail": "->DataFrame", "apply": "sort(${\"sortExprs_varargs: Column(Vararg)\"})", "info": "\n<pre>(['sortExprs_varargs: Column'])->DataFrame \n\nsort(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Returns a new DataFrame sorted by the given expressions.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "sortWithinPartitions", "detail": "->DataFrame", "apply": "sortWithinPartitions(${\"sortExprs_varargs: Column(Vararg)\"})", "info": "\n<pre>(['sortExprs_varargs: Column'])->DataFrame \n\nsortWithinPartitions(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Returns a new DataFrame with each partition sorted by the given expressions. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "unionAll", "detail": "->DataFrame", "apply": "unionAll(${\"other: DataFrame\"})", "info": "\n<pre>(['other: DataFrame'])->DataFrame \n\nunionAll(%r)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Returns a new DataFrame containing union of rows in this frame and another frame.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "withColumn", "detail": "->DataFrame", "apply": "withColumn(${\"colName: string\"}, ${\"col: Column\"})", "info": "\n<pre>(['colName: string', ' col: Column'])->DataFrame \n\nwithColumn(%s, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Returns a new DataFrame by adding a column or replacing the existing column that has the same name.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "withColumnRenamed", "detail": "->DataFrame", "apply": "withColumnRenamed(${\"existingName: string\"}, ${\"newName: string\"})", "info": "\n<pre>(['existingName: string', ' newName: string'])->DataFrame \n\nwithColumnRenamed(%s, %s)\n</pre>\n<hr class=\"solid\">\n<p>[Data Frame Functions]</p>\n<p>Returns a new DataFrame with a column renamed.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "xpath", "detail": "->Column", "apply": "callUDF(\"xpath\", ${\"xml: string\"}, ${\"xpath: string\"})", "info": "\n<pre>(['xml: string', ' xpath: string'])->Column \n\ncallUDF(\"xpath\", %c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Hive Functions]</p>\n<p>Returns a string array of values within xml nodes that match the xpath expression</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "xpath_double", "detail": "->Column", "apply": "callUDF(\"xpath_double\", ${\"xml: string\"}, ${\"xpath: string\"})", "info": "\n<pre>(['xml: string', ' xpath: string'])->Column \n\ncallUDF(\"xpath_double\", %c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Hive Functions]</p>\n<p>Returns a double value that matches the xpath expression</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "xpath_float", "detail": "->Column", "apply": "callUDF(\"xpath_float\", ${\"xml: string\"}, ${\"xpath: string\"})", "info": "\n<pre>(['xml: string', ' xpath: string'])->Column \n\ncallUDF(\"xpath_float\", %c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Hive Functions]</p>\n<p>Returns a float value that matches the xpath expression</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "xpath_int", "detail": "->Column", "apply": "callUDF(\"xpath_int\", ${\"xml: string\"}, ${\"xpath: string\"})", "info": "\n<pre>(['xml: string', ' xpath: string'])->Column \n\ncallUDF(\"xpath_int\", %c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Hive Functions]</p>\n<p>Returns an integer value that matches the xpath expression</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "xpath_long", "detail": "->Column", "apply": "callUDF(\"xpath_long\", ${\"xml: string\"}, ${\"xpath: string\"})", "info": "\n<pre>(['xml: string', ' xpath: string'])->Column \n\ncallUDF(\"xpath_long\", %c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Hive Functions]</p>\n<p>Returns a long value that matches the xpath expression</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "xpath_number", "detail": "->Column", "apply": "callUDF(\"xpath_number\", ${\"xml: string\"}, ${\"xpath: string\"})", "info": "\n<pre>(['xml: string', ' xpath: string'])->Column \n\ncallUDF(\"xpath_number\", %c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Hive Functions]</p>\n<p>Returns a double value that matches the xpath expression</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "xpath_short", "detail": "->Column", "apply": "callUDF(\"xpath_short\", ${\"xml: string\"}, ${\"xpath: string\"})", "info": "\n<pre>(['xml: string', ' xpath: string'])->Column \n\ncallUDF(\"xpath_short\", %c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Hive Functions]</p>\n<p>Returns a short value that matches the xpath expression</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "xpath_string", "detail": "->Column", "apply": "callUDF(\"xpath_string\", ${\"xml: string\"}, ${\"xpath: string\"})", "info": "\n<pre>(['xml: string', ' xpath: string'])->Column \n\ncallUDF(\"xpath_string\", %c, %c)\n</pre>\n<hr class=\"solid\">\n<p>[Hive Functions]</p>\n<p>Returns the text contents of the first xml node that matches the xpath expression</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "AFTSurvivalRegression", "detail": "->AFTSurvivalRegression", "apply": "new org.apache.spark.ml.regression.AFTSurvivalRegression()", "info": "\n<pre>([''])->AFTSurvivalRegression \n\nnew org.apache.spark.ml.regression.AFTSurvivalRegression()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Fit a parametric survival regression model named accelerated failure time (AFT) model based on the Weibull distribution of the survival time. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "ALS", "detail": "->ALS", "apply": "new org.apache.spark.ml.recommendation.ALS()", "info": "\n<pre>([''])->ALS \n\nnew org.apache.spark.ml.recommendation.ALS()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Alternating Least Squares (ALS) matrix factorization.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "binarizer", "detail": "->DataFrame", "apply": "new org.apache.spark.ml.feature.Binarizer().setInputCol(${\"inputCol: string\"}).setOutputCol(${\"outputCol: string\"}).setThreshold(${\"threshold: number\"}).transform", "info": "\n<pre>(['inputCol: string', ' outputCol: string', ' threshold: number'])->DataFrame \n\nnew org.apache.spark.ml.feature.Binarizer().setInputCol(%s).setOutputCol(%s).setThreshold(%f).transform\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Binarize a column of continuous features given a threshold.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "BinaryClassificationEvaluator", "detail": "->Evaluator", "apply": "new org.apache.spark.ml.evaluation.BinaryClassificationEvaluator().setMetricName(${\"metricName: string\"}).setLabelCol(${\"labelCol: string\"}).setRawPredictionCol(${\"rawPredictionCol: string\"})", "info": "\n<pre>(['metricName: string', ' labelCol: string', ' rawPredictionCol: string'])->Evaluator \n\nnew org.apache.spark.ml.evaluation.BinaryClassificationEvaluator().setMetricName(%s).setLabelCol(%s).setRawPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Evaluator for binary classification, which expects two input columns: rawPrediction and label.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "BisectingKMeans", "detail": "->BisectingKMeans", "apply": "new org.apache.spark.ml.clustering.BisectingKMeans()", "info": "\n<pre>([''])->BisectingKMeans \n\nnew org.apache.spark.ml.clustering.BisectingKMeans()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>A bisecting k-means algorithm based on the paper \"A comparsion of document clustering techniques\" by Steinbach, Karypis, and Kumar, with modification to fit Spark. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "BucketedRandomProjectionLSH", "detail": "->BucketedRandomProjectionLSH", "apply": "new org.apache.spark.ml.feature.BucketedRandomProjectionLSH()", "info": "\n<pre>([''])->BucketedRandomProjectionLSH \n\nnew org.apache.spark.ml.feature.BucketedRandomProjectionLSH()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>This BucketedRandomProjectionLSH implements Locality Sensitive Hashing functions for Euclidean distance metrics. (Spark 2.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "ChiSqSelector", "detail": "->ChiSqSelector", "apply": "new org.apache.spark.ml.feature.ChiSqSelector()", "info": "\n<pre>([''])->ChiSqSelector \n\nnew org.apache.spark.ml.feature.ChiSqSelector()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Chi-Squared feature selection, which selects categorical features to use for predicting a categorical label. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "Correlation", "detail": "->DataFrame", "apply": "org.apache.spark.ml.stat.Correlation.corr(${\"dataset: DataSet\"}, ${\"column: string\"} ${3:\"opt_method: string(Optional)\"})", "info": "\n<pre>(['dataset: DataSet', ' column: string', ' opt_method: string'])->DataFrame \n\norg.apache.spark.ml.stat.Correlation.corr(%r, %s%,?s)\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Compute the correlation matrix for the input Dataset of Vectors using the specified method.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "CountVectorizer", "detail": "->CountVectorizer", "apply": "new org.apache.spark.ml.feature.CountVectorizer()", "info": "\n<pre>([''])->CountVectorizer \n\nnew org.apache.spark.ml.feature.CountVectorizer()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Extracts a vocabulary from document collections.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "dct", "detail": "->DataFrame", "apply": "new org.apache.spark.ml.feature.DCT().setInputCol(${\"inputCol: string\"}).setOutputCol(${\"outputCol: string\"}).setInverse(${\"inverse: boolean\"}).transform", "info": "\n<pre>(['inputCol: string', ' outputCol: string', ' inverse: boolean'])->DataFrame \n\nnew org.apache.spark.ml.feature.DCT().setInputCol(%s).setOutputCol(%s).setInverse(%b).transform\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>A feature transformer that takes the 1D discrete cosine transform of a real vector.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "DecisionTreeClassifier", "detail": "->DecisionTreeClassifier", "apply": "new org.apache.spark.ml.classification.DecisionTreeClassifier()", "info": "\n<pre>([''])->DecisionTreeClassifier \n\nnew org.apache.spark.ml.classification.DecisionTreeClassifier()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Decision tree learning algorithm or classification.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "DecisionTreeRegressor", "detail": "->DecisionTreeRegressor", "apply": "new org.apache.spark.ml.regression.DecisionTreeRegressor()", "info": "\n<pre>([''])->DecisionTreeRegressor \n\nnew org.apache.spark.ml.regression.DecisionTreeRegressor()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Decision tree learning algorithm for regression.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "elementwiseProduct", "detail": "->DataFrame", "apply": "new org.apache.spark.ml.feature.ElementwiseProduct().setInputCol(${\"inputCol: string\"}).setOutputCol(${\"outputCol: string\"}).setScalingVec(${\"scalingVec: Vector\"}).transform", "info": "\n<pre>(['inputCol: string', ' outputCol: string', ' scalingVec: Vector'])->DataFrame \n\nnew org.apache.spark.ml.feature.ElementwiseProduct().setInputCol(%s).setOutputCol(%s).setScalingVec(%o).transform\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Outputs the Hadamard product of each input vector with a provided \"weight\" vector.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "FPGrowth", "detail": "->FPGrowth", "apply": "new org.apache.spark.ml.fpm.FPGrowth()", "info": "\n<pre>([''])->FPGrowth \n\nnew org.apache.spark.ml.fpm.FPGrowth()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>A parallel FP-growth algorithm to mine frequent itemsets. (Spark 2.2)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "GBTClassifier", "detail": "->GBTClassifier", "apply": "new org.apache.spark.ml.classification.GBTClassifer()", "info": "\n<pre>([''])->GBTClassifier \n\nnew org.apache.spark.ml.classification.GBTClassifer()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Gradient-Boosted Trees (GBTs) learning algorithm for classification.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "GBTRegressor", "detail": "->GBTRegressor", "apply": "new org.apache.spark.ml.classification.GBTRegressor()", "info": "\n<pre>([''])->GBTRegressor \n\nnew org.apache.spark.ml.classification.GBTRegressor()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Gradient-Boosted Trees (GBTs) learning algorithm for regression.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "GaussianMixture", "detail": "->GaussianMixture", "apply": "new org.apache.spark.ml.clustering.GaussianMixture()", "info": "\n<pre>([''])->GaussianMixture \n\nnew org.apache.spark.ml.clustering.GaussianMixture()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Gaussian Mixture clustering. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "GeneralizedLinearRegression", "detail": "->GeneralizedLinearRegression", "apply": "new org.apache.spark.ml.regression.GeneralizedLinearRegression()", "info": "\n<pre>([''])->GeneralizedLinearRegression \n\nnew org.apache.spark.ml.regression.GeneralizedLinearRegression()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Fit a Generalized Linear Model specified by giving a symbolic description of the linear predictor (link function) and a description of the error distribution (family). (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "hashingTF", "detail": "->DataFrame", "apply": "new org.apache.spark.ml.feature.HashingTF().setInputCol(${\"inputCol: string\"}).setOutputCol(${\"outputCol: string\"}).setBinary(${\"binary: boolean\"}).setNumFeatures(${\"numFeatures: number\"}).transform", "info": "\n<pre>(['inputCol: string', ' outputCol: string', ' binary: boolean', ' numFeatures: number'])->DataFrame \n\nnew org.apache.spark.ml.feature.HashingTF().setInputCol(%s).setOutputCol(%s).setBinary(%b).setNumFeatures(%d).transform\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Maps a sequence of terms to their term frequencies using the hashing trick.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "IDF", "detail": "->IDF", "apply": "new org.apache.spark.ml.feature.IDF()", "info": "\n<pre>([''])->IDF \n\nnew org.apache.spark.ml.feature.IDF()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Compute the Inverse Document Frequency (IDF) given a collection of documents.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "Imputer", "detail": "->Imputer", "apply": "new org.apache.spark.ml.feature.Imputer()", "info": "\n<pre>([''])->Imputer \n\nnew org.apache.spark.ml.feature.Imputer()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Imputation estimator for completing missing values. (Spark 2.2)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "indexToString", "detail": "->DataFrame", "apply": "new org.apache.spark.ml.feature.IndexToString().setInputCol(${\"inputCol: string\"}).setOutputCol(${\"outputCol: string\"}).setLabels(${\"labels: [string](Array)\"}).transform", "info": "\n<pre>(['inputCol: string', ' outputCol: string', ' labels: [string]'])->DataFrame \n\nnew org.apache.spark.ml.feature.IndexToString().setInputCol(%s).setOutputCol(%s).setLabels(%@s).transform\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>A Transformer that maps a column of indices back to a new column of corresponding string values.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "interaction", "detail": "->DataFrame", "apply": "new org.apache.spark.ml.feature.Interaction().setInputCols(${\"inputCols: [string](Array)\"}).setOutputCol(${\"outputCol: string\"}).transform", "info": "\n<pre>(['inputCols: [string]', ' outputCol: string'])->DataFrame \n\nnew org.apache.spark.ml.feature.Interaction().setInputCols(%@s).setOutputCol(%s).transform\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Implements the feature interaction transform. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "IsotonicRegression", "detail": "->IsotonicRegression", "apply": "new org.apache.spark.ml.regression.IsotonicRegression()", "info": "\n<pre>([''])->IsotonicRegression \n\nnew org.apache.spark.ml.regression.IsotonicRegression()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Isotonic regression.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "KMeans", "detail": "->KMeans", "apply": "new org.apache.spark.ml.clustering.KMeans()", "info": "\n<pre>([''])->KMeans \n\nnew org.apache.spark.ml.clustering.KMeans()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>K-means clustering with support for k-means.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "LDA", "detail": "->LDA", "apply": "new org.apache.spark.ml.clustering.LDA()", "info": "\n<pre>([''])->LDA \n\nnew org.apache.spark.ml.clustering.LDA()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Latent Dirichlet Allocation (LDA), a topic model designed for text documents. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "LinearRegression", "detail": "->LinearRegression", "apply": "new org.apache.spark.ml.regression.LinearRegression()", "info": "\n<pre>([''])->LinearRegression \n\nnew org.apache.spark.ml.regression.LinearRegression()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Linear regression.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "LinearSVC", "detail": "->LinearSVC", "apply": "new org.apache.spark.ml.classification.LinearSVC()", "info": "\n<pre>([''])->LinearSVC \n\nnew org.apache.spark.ml.classification.LinearSVC()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>This binary classifier optimizes the Hinge Loss using the OWLQN optimizer. (Spark 2.2)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "LogisticRegression", "detail": "->LogisticRegression", "apply": "new org.apache.spark.ml.classification.LogisticRegression()", "info": "\n<pre>([''])->LogisticRegression \n\nnew org.apache.spark.ml.classification.LogisticRegression()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Logistic regression.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "MaxAbsScaler", "detail": "->MaxAbsScaler", "apply": "new org.apache.spark.ml.feature.MaxAbsScaler()", "info": "\n<pre>([''])->MaxAbsScaler \n\nnew org.apache.spark.ml.feature.MaxAbsScaler()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Rescale each feature individually to range [-1, 1] by dividing through the largest maximum absolute value in each feature. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "MinHashLSH", "detail": "->MinHashLSH", "apply": "new org.apache.spark.ml.feature.MinHashLSH()", "info": "\n<pre>([''])->MinHashLSH \n\nnew org.apache.spark.ml.feature.MinHashLSH()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>LSH class for Jaccard distance. (Spark 2.1)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "MinMaxScaler", "detail": "->MinMaxScaler", "apply": "new org.apache.spark.ml.feature.MinMaxScaler()", "info": "\n<pre>([''])->MinMaxScaler \n\nnew org.apache.spark.ml.feature.MinMaxScaler()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Rescale each feature individually to a common range [min, max] linearly using column summary statistics, which is also known as min-max normalization or Rescaling.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "MulticlassClassificationEvaluator", "detail": "->Evaluator", "apply": "new org.apache.spark.ml.evaluation.MulticlassClassificationEvaluator().setMetricName(${\"metricName: string\"}).setLabelCol(${\"labelCol: string\"}).setPredictionCol(${\"predictionCol: string\"})", "info": "\n<pre>(['metricName: string', ' labelCol: string', ' predictionCol: string'])->Evaluator \n\nnew org.apache.spark.ml.evaluation.MulticlassClassificationEvaluator().setMetricName(%s).setLabelCol(%s).setPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Evaluator for multiclass classification, which expects two input columns: prediction and label.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "MultilayerPerceptronClassifier", "detail": "->MultilayerPerceptronClassifier", "apply": "new org.apache.spark.ml.classification.MultilayerPerceptronClassifier()", "info": "\n<pre>([''])->MultilayerPerceptronClassifier \n\nnew org.apache.spark.ml.classification.MultilayerPerceptronClassifier()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Classifier trainer based on the Multilayer Perceptron.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "nGram", "detail": "->DataFrame", "apply": "new org.apache.spark.ml.feature.NGram().setInputCol(${\"inputCol: string\"}).setOutputCol(${\"outputCol: string\"}).setN(${\"n: number\"}).transform", "info": "\n<pre>(['inputCol: string', ' outputCol: string', ' n: number'])->DataFrame \n\nnew org.apache.spark.ml.feature.NGram().setInputCol(%s).setOutputCol(%s).setN(%d).transform\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>A feature transformer that converts the input array of strings into an array of n-grams.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "NaiveBayes", "detail": "->NaiveBayes", "apply": "new org.apache.spark.ml.classification.NaiveBayes()", "info": "\n<pre>([''])->NaiveBayes \n\nnew org.apache.spark.ml.classification.NaiveBayes()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Naive Bayes Classifiers.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "normalizer", "detail": "->DataFrame", "apply": "new org.apache.spark.ml.feature.Normalizer().setInputCol(${\"inputCol: string\"}).setOutputCol(${\"outputCol: string\"}).setP(${\"p: number\"}).transform", "info": "\n<pre>(['inputCol: string', ' outputCol: string', ' p: number'])->DataFrame \n\nnew org.apache.spark.ml.feature.Normalizer().setInputCol(%s).setOutputCol(%s).setP(%f).transform\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Normalize a vector to have unit norm using the given p-norm.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "oneHotEncoder", "detail": "->DataFrame", "apply": "new org.apache.spark.ml.feature.OneHotEncoder().setInputCol(${\"inputCol: string\"}).setOutputCol(${\"outputCol: string\"}).setDropLast(${\"dropLast: boolean\"}).transform", "info": "\n<pre>(['inputCol: string', ' outputCol: string', ' dropLast: boolean'])->DataFrame \n\nnew org.apache.spark.ml.feature.OneHotEncoder().setInputCol(%s).setOutputCol(%s).setDropLast(%b).transform\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>A one-hot encoder that maps a column of category indices to a column of binary vectors, with at most a single one-value per row that indicates the input category index.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "OneVsRest", "detail": "->OneVsRest", "apply": "new org.apache.spark.ml.classification.OneVsRest()", "info": "\n<pre>([''])->OneVsRest \n\nnew org.apache.spark.ml.classification.OneVsRest()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Reduction of Multiclass Classification to Binary Classification.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "PCA", "detail": "->PCA", "apply": "new org.apache.spark.ml.feature.PCA()", "info": "\n<pre>([''])->PCA \n\nnew org.apache.spark.ml.feature.PCA()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>PCA trains a model to project vectors to a lower dimensional space of the top PCA!.k principal components.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "polynomialExpansion", "detail": "->DataFrame", "apply": "new org.apache.spark.ml.feature.PolynomialExpansion().setInputCol(${\"inputCol: string\"}).setOutputCol(${\"outputCol: string\"}).setDegree(${\"degree: number\"}).transform", "info": "\n<pre>(['inputCol: string', ' outputCol: string', ' degree: number'])->DataFrame \n\nnew org.apache.spark.ml.feature.PolynomialExpansion().setInputCol(%s).setOutputCol(%s).setDegree(%d).transform\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Perform feature expansion in a polynomial space.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "ProbabilisticClassifier", "detail": "->ProbabilisticClassifier", "apply": "new org.apache.spark.ml.classification.ProbabilisticClassifier()", "info": "\n<pre>([''])->ProbabilisticClassifier \n\nnew org.apache.spark.ml.classification.ProbabilisticClassifier()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Single-label binary or multiclass classifier which can output class conditional probabilities.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "QuantileDiscretizer", "detail": "->QuantileDiscretizer", "apply": "new org.apache.spark.ml.feature.QuantileDiscretizer()", "info": "\n<pre>([''])->QuantileDiscretizer \n\nnew org.apache.spark.ml.feature.QuantileDiscretizer()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>QuantileDiscretizer takes a column with continuous features and outputs a column with binned categorical features. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "RFormula", "detail": "->RFormula", "apply": "new org.apache.spark.ml.feature.RFormula()", "info": "\n<pre>([''])->RFormula \n\nnew org.apache.spark.ml.feature.RFormula()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Implements the transforms required for fitting a dataset against an R model formula.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "RandomForestClassifier", "detail": "->RandomForestClassifier", "apply": "new org.apache.spark.ml.classification.RandomForestClassifier()", "info": "\n<pre>([''])->RandomForestClassifier \n\nnew org.apache.spark.ml.classification.RandomForestClassifier()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Random Forest learning algorithm for classification.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "RandomForestRegressor", "detail": "->RandomForestRegressor", "apply": "new org.apache.spark.ml.regression.RandomForestRegressor()", "info": "\n<pre>([''])->RandomForestRegressor \n\nnew org.apache.spark.ml.regression.RandomForestRegressor()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Random Forest learning algorithm for regression.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "RegexTokenizer", "detail": "->RegexTokenizer", "apply": "new org.apache.spark.ml.feature.RegexTokenizer()", "info": "\n<pre>([''])->RegexTokenizer \n\nnew org.apache.spark.ml.feature.RegexTokenizer()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>A regex based tokenizer that extracts tokens either by using the provided regex pattern to split the text (default) or repeatedly matching the regex (if gaps is false).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "RegressionEvaluator", "detail": "->Evaluator", "apply": "new org.apache.spark.ml.evaluation.RegressionEvaluator().setMetricName(${\"metricName: string\"}).setLabelCol(${\"labelCol: string\"}).setPredictionCol(${\"predictionCol: string\"})", "info": "\n<pre>(['metricName: string', ' labelCol: string', ' predictionCol: string'])->Evaluator \n\nnew org.apache.spark.ml.evaluation.RegressionEvaluator().setMetricName(%s).setLabelCol(%s).setPredictionCol(%s)\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Evaluator for regression, which expects two input columns: prediction and label.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "sqlTransformer", "detail": "->DataFrame", "apply": "new org.apache.spark.ml.feature.SQLTransformer().setStatement(${\"statement: string\"}).transform", "info": "\n<pre>(['statement: string'])->DataFrame \n\nnew org.apache.spark.ml.feature.SQLTransformer().setStatement(%s).transform\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Implements the transformations which are defined by SQL statement. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "StandardScaler", "detail": "->StandardScaler", "apply": "new org.apache.spark.ml.feature.StandardScaler()", "info": "\n<pre>([''])->StandardScaler \n\nnew org.apache.spark.ml.feature.StandardScaler()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Standardizes features by removing the mean and scaling to unit variance using column summary statistics on the samples in the training set.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "stopWordsRemover", "detail": "->DataFrame", "apply": "new org.apache.spark.ml.feature.StopWordsRemover().setInputCol(${\"inputCol: string\"}).setOutputCol(${\"outputCol: string\"}).setCaseSensitive(${\"caseSensitive: boolean\"}).setStopWords(${\"stopWords: [string](Array)\"}).transform", "info": "\n<pre>(['inputCol: string', ' outputCol: string', ' caseSensitive: boolean', ' stopWords: [string]'])->DataFrame \n\nnew org.apache.spark.ml.feature.StopWordsRemover().setInputCol(%s).setOutputCol(%s).setCaseSensitive(%b).setStopWords(%@s).transform\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>A feature transformer that filters out stop words from input.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "StringIndexer", "detail": "->StringIndexer", "apply": "new org.apache.spark.ml.feature.StringIndexer()", "info": "\n<pre>([''])->StringIndexer \n\nnew org.apache.spark.ml.feature.StringIndexer()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>A label indexer that maps a string column of labels to an ML column of label indices.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "tokenizer", "detail": "->DataFrame", "apply": "new org.apache.spark.ml.feature.Tokenizer().setInputCol(${\"inputCol: string\"}).setOutputCol(${\"outputCol: string\"}).transform", "info": "\n<pre>(['inputCol: string', ' outputCol: string'])->DataFrame \n\nnew org.apache.spark.ml.feature.Tokenizer().setInputCol(%s).setOutputCol(%s).transform\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>A tokenizer that converts the input string to lowercase and then splits it by white spaces.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "transform", "detail": "->DataFrame", "apply": "org.apache.spark.ml.PipelineModel.load(${\"modelPath: string\"}).transform", "info": "\n<pre>(['modelPath: string'])->DataFrame \n\norg.apache.spark.ml.PipelineModel.load(%s).transform\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Transforms the dataset. (Spark 1.6)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "vector", "detail": "->Vector", "apply": "org.apache.spark.ml.linalg.Vectors.dense(${\"values_varargs: number(Vararg)\"})", "info": "\n<pre>(['values_varargs: number'])->Vector \n\norg.apache.spark.ml.linalg.Vectors.dense(%*f)\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Creates a dense vector from its values.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "vectorAssembler", "detail": "->DataFrame", "apply": "new org.apache.spark.ml.feature.VectorAssembler().setInputCols(${\"inputCols: [string](Array)\"}).setOutputCol(${\"outputCol: string\"}).transform", "info": "\n<pre>(['inputCols: [string]', ' outputCol: string'])->DataFrame \n\nnew org.apache.spark.ml.feature.VectorAssembler().setInputCols(%@s).setOutputCol(%s).transform\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>A feature transformer that merges multiple columns into a vector column.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "VectorIndexer", "detail": "->VectorIndexer", "apply": "new org.apache.spark.ml.feature.VectorIndexer()", "info": "\n<pre>([''])->VectorIndexer \n\nnew org.apache.spark.ml.feature.VectorIndexer()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Class for indexing categorical feature columns in a dataset of Vector.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "vectorSlicer", "detail": "->DataFrame", "apply": "new org.apache.spark.ml.feature.VectorSlicer().setInputCol(${\"inputCol: string\"}).setOutputCol(${\"outputCol: string\"}).setIndices(${\"indices: [number](Array)\"}).setNames(${\"names: [string](Array)\"}).transform", "info": "\n<pre>(['inputCol: string', ' outputCol: string', ' indices: [number]', ' names: [string]'])->DataFrame \n\nnew org.apache.spark.ml.feature.VectorSlicer().setInputCol(%s).setOutputCol(%s).setIndices(%@d).setNames(%@s).transform\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>This class takes a feature vector and outputs a new feature vector with a subarray of the original features.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "Word2Vec", "detail": "->Word2Vec", "apply": "new org.apache.spark.ml.feature.Word2Vec()", "info": "\n<pre>([''])->Word2Vec \n\nnew org.apache.spark.ml.feature.Word2Vec()\n</pre>\n<hr class=\"solid\">\n<p>[Machine Learning Functions]</p>\n<p>Word2Vec trains a model of Map(String, Vector).</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "approxQuantile", "detail": "->Column", "apply": "lit(df.stat.approxQuantile(${\"col: string\"}, ${\"probabilities: [number](Array)\"}, ${\"relativeError: number\"}))", "info": "\n<pre>(['col: string', ' probabilities: [number]', ' relativeError: number'])->Column \n\nlit(df.stat.approxQuantile(%s, %@f, %f))\n</pre>\n<hr class=\"solid\">\n<p>[Stat Functions]</p>\n<p>Calculates the approximate quantiles of numerical columns of a DataFrame. (Spark 2.0)</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "crosstab", "detail": "->DataFrame", "apply": "stat.crosstab(${\"col1: string\"}, ${\"col2: string\"})", "info": "\n<pre>(['col1: string', ' col2: string'])->DataFrame \n\nstat.crosstab(%s, %s)\n</pre>\n<hr class=\"solid\">\n<p>[Stat Functions]</p>\n<p>Computes a pair-wise frequency table of the given columns.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "freqItems", "detail": "->DataFrame", "apply": "stat.freqItems(${\"cols: [string](Array)\"} ${2:\"support: number(Optional)\"})", "info": "\n<pre>(['cols: [string]', ' support: number'])->DataFrame \n\nstat.freqItems(%@s%,?f)\n</pre>\n<hr class=\"solid\">\n<p>[Stat Functions]</p>\n<p>Finding frequent items for columns, possibly with false positives.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "orderBy", "detail": "->WindowSpec", "apply": "org.apache.spark.sql.expressions.Window.orderBy(${\"cols_varargs: Column(Vararg)\"})", "info": "\n<pre>(['cols_varargs: Column'])->WindowSpec \n\norg.apache.spark.sql.expressions.Window.orderBy(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[Window Spec Functions]</p>\n<p>Creates a WindowSpec with the ordering defined.</p>\n", "type": "function"}, {"py/object": "__main__.CodeMirrorCompletion", "label": "partitionBy", "detail": "->WindowSpec", "apply": "org.apache.spark.sql.expressions.Window.partitionBy(${\"cols_varargs: Column(Vararg)\"})", "info": "\n<pre>(['cols_varargs: Column'])->WindowSpec \n\norg.apache.spark.sql.expressions.Window.partitionBy(%*c)\n</pre>\n<hr class=\"solid\">\n<p>[Window Spec Functions]</p>\n<p>Creates a WindowSpec with the partitioning defined.</p>\n", "type": "function"}]